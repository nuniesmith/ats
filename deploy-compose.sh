#!/bin/bash
# Deploy ATS services using Docker Compose with GitHub Actions secrets

set -e

echo "üöÄ Deploying ATS Game Server with Docker Compose..."

# Create environment file with secrets from GitHub Actions
create_env_file() {
    echo "üîß Creating environment configuration..."
    cat > .env << EOF
# Generated by GitHub Actions - $(date)
NODE_ENV=production
TZ=America/Toronto

# ATS Game Server Configuration
ATS_SERVER_NAME="Freddy's ATS Server"
ATS_SERVER_PASSWORD="${ATS_ROOT_PASSWORD:-ruby}"
ATS_MAX_PLAYERS=8
ATS_SERVER_PORT=27015
ATS_QUERY_PORT=27016
ATS_WELCOME_MESSAGE="Welcome to Freddy's American Truck Simulator server!"
ATS_LOGON_TOKEN=""
STEAM_COLLECTION_ID=3530633316
ATS_ENABLE_PVP=false
ATS_SPEED_LIMITER=true
ATS_FUEL_CONSUMPTION=1.0

# Web Interface Configuration
VITE_API_URL=http://localhost/api
VITE_SOCKET_URL=http://localhost

# API Server Configuration
JWT_SECRET="${ATS_ROOT_PASSWORD:-ruby}-jwt"
FRONTEND_URL=http://localhost
ATS_DEFAULT_PASSWORD="${ATS_ROOT_PASSWORD:-ruby}"

# External Services
CLOUDFLARE_API_TOKEN="${CLOUDFLARE_API_TOKEN:-}"
CLOUDFLARE_ZONE_ID="${CLOUDFLARE_ZONE_ID:-}"
DOMAIN_NAME=ats.7gram.xyz
DISCORD_WEBHOOK_URL="${DISCORD_WEBHOOK:-}"
REDIS_URL=redis://redis:6379

# Monitoring
NETDATA_CLAIM_TOKEN="${NETDATA_CLAIM_TOKEN:-}"
NETDATA_CLAIM_URL=https://app.netdata.cloud
NETDATA_CLAIM_ROOMS="${NETDATA_CLAIM_ROOM:-}"

# Docker Images
WEB_IMAGE=nuniesmith/ats:web-latest
API_IMAGE=nuniesmith/ats:api-latest
ATS_SERVER_IMAGE=nuniesmith/ats:server-latest
EOF
    
    echo "‚úÖ Environment file created"
}

# Function to fix Docker networking issues
fix_docker_networking() {
    echo "üîß Checking and fixing Docker networking..."
    
    # Check if Docker iptables chains exist
    if ! sudo iptables -t nat -L DOCKER >/dev/null 2>&1; then
        echo "‚ö†Ô∏è Docker iptables chains missing, performing reset..."
        
        # Stop Docker
        sudo systemctl stop docker docker.socket
        
        # Clean up iptables
        sudo iptables -t nat -F DOCKER 2>/dev/null || true
        sudo iptables -t filter -F DOCKER 2>/dev/null || true
        sudo iptables -t nat -X DOCKER 2>/dev/null || true
        sudo iptables -t filter -X DOCKER 2>/dev/null || true
        
        # Clean up network interfaces
        for interface in $(ip link show | grep br- | cut -d: -f2 | tr -d " "); do
            echo "  Removing bridge: $interface"
            sudo ip link delete "$interface" 2>/dev/null || true
        done
        
        # Restart Docker
        sudo systemctl start docker.socket docker
        sleep 10
        
        echo "‚úÖ Docker networking reset completed"
    else
        echo "‚úÖ Docker networking is healthy"
    fi
}

# Function to determine Docker Compose command
get_compose_cmd() {
    if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
        echo "docker compose"
    elif command -v docker-compose >/dev/null 2>&1; then
        echo "docker-compose"
    else
        echo ""
    fi
}

# Main deployment function
deploy_services() {
    local compose_cmd=$(get_compose_cmd)
    
    if [[ -z "$compose_cmd" ]]; then
        echo "‚ùå No Docker Compose command available"
        return 1
    fi
    
    echo "üìã Using Docker Compose command: $compose_cmd"
    
    # Stop and clean up existing services
    echo "üßπ Cleaning up existing services..."
    $compose_cmd down --remove-orphans 2>/dev/null || true
    docker network prune -f 2>/dev/null || true
    
    # Pull/build images
    echo "üê≥ Pulling and building Docker images..."
    $compose_cmd pull --ignore-pull-failures || echo "Some images may not exist yet"
    $compose_cmd build --no-cache || echo "Build completed with warnings"
    
    # Create networks if they don't exist
    echo "üåê Creating Docker networks..."
    docker network create ats-network 2>/dev/null || echo "Network ats-network already exists"
    
    # Start services
    echo "üöÄ Starting ATS services..."
    if $compose_cmd up -d; then
        echo "‚úÖ Docker Compose services started successfully"
        return 0
    else
        echo "‚ö†Ô∏è Docker Compose failed, trying manual startup..."
        return 1
    fi
}

# Manual service startup fallback
manual_startup() {
    echo "üîß Starting services manually..."
    
    # Create network
    docker network create ats-network 2>/dev/null || true
    
    # Start Redis
    echo "üî¥ Starting Redis..."
    docker run -d --name ats-redis --restart unless-stopped \
        --network ats-network \
        -v ats-redis-data:/data \
        redis:7-alpine redis-server --appendonly yes && \
        echo "‚úÖ Redis started" || echo "‚ö†Ô∏è Redis startup failed"
    sleep 5
    
    # Start API service
    echo "üîß Starting API service..."
    docker run -d --name ats-api-server --restart unless-stopped \
        --network ats-network \
        --env-file .env \
        -v ats-data:/app/data \
        -v ats-logs:/app/logs \
        -v ats-config:/app/config \
        nuniesmith/ats:api-latest && \
        echo "‚úÖ API service started" || echo "‚ö†Ô∏è API startup failed"
    sleep 10
    
    # Start web interface
    echo "üåê Starting web interface..."
    docker run -d --name ats-web-app --restart unless-stopped \
        --network ats-network \
        --env-file .env \
        nuniesmith/ats:web-latest && \
        echo "‚úÖ Web interface started" || echo "‚ö†Ô∏è Web startup failed"
    sleep 5
    
    # Start ATS game server
    echo "üéÆ Starting ATS game server..."
    docker run -d --name ats-dedicated-server --restart unless-stopped \
        --network ats-network \
        --env-file .env \
        -p 27015:27015/tcp -p 27015:27015/udp \
        -v ats-server-data:/app/data \
        -v ats-server-logs:/app/logs \
        -v ats-server-config:/app/config \
        nuniesmith/ats:server-latest && \
        echo "‚úÖ ATS game server started" || echo "‚ö†Ô∏è Game server startup failed"
    sleep 10
    
    # Start Nginx proxy
    echo "üîÑ Starting Nginx proxy..."
    docker run -d --name ats-nginx-proxy --restart unless-stopped \
        --network ats-network \
        -p 80:80 -p 443:443 \
        -v $(pwd)/config/nginx.conf:/etc/nginx/nginx.conf:ro \
        nginx:alpine && \
        echo "‚úÖ Nginx proxy started" || echo "‚ö†Ô∏è Nginx startup failed"
}

# Service verification
verify_services() {
    echo ""
    echo "üìä === SERVICE VERIFICATION ==="
    
    # Check running containers
    echo "üìã Running containers:"
    docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    
    # Port checks
    echo ""
    echo "üîå Port connectivity:"
    for port in 80 443 8080 3000 3001 27015; do
        if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
            echo "‚úÖ Port $port: LISTENING"
        else
            echo "‚ùå Port $port: NOT LISTENING"
        fi
    done
    
    # Health checks
    echo ""
    echo "üè• Service health checks:"
    
    # Web interface
    if curl -s --max-time 10 "http://localhost" >/dev/null 2>&1; then
        echo "‚úÖ Web interface: HEALTHY"
    else
        echo "‚ùå Web interface: NOT RESPONDING"
    fi
    
    # API service
    if curl -s --max-time 10 "http://localhost:3001/health" >/dev/null 2>&1; then
        echo "‚úÖ API service: HEALTHY"
    elif curl -s --max-time 10 "http://localhost:3001" >/dev/null 2>&1; then
        echo "‚úÖ API service: RESPONDING"
    else
        echo "‚ùå API service: NOT RESPONDING"
    fi
    
    # Game server
    if netstat -tlnp 2>/dev/null | grep -q ':27015 '; then
        echo "‚úÖ Game server: LISTENING"
    else
        echo "‚ùå Game server: NOT LISTENING"
    fi
    
    echo ""
    echo "üéØ Deployment completed!"
}

# Main execution
main() {
    # Change to script directory
    cd "$(dirname "$0")" || exit 1
    
    # Set environment variables from arguments (for GitHub Actions)
    export ATS_ROOT_PASSWORD="${1:-ruby}"
    export CLOUDFLARE_API_TOKEN="${2:-}"
    export CLOUDFLARE_ZONE_ID="${3:-}"
    export DISCORD_WEBHOOK="${4:-}"
    export NETDATA_CLAIM_TOKEN="${5:-}"
    export NETDATA_CLAIM_ROOM="${6:-}"
    
    # Create environment file
    create_env_file
    
    # Fix Docker networking if needed
    fix_docker_networking
    
    # Try Docker Compose deployment
    if ! deploy_services; then
        echo "üîß Docker Compose failed, trying manual startup..."
        manual_startup
    fi
    
    # Wait for services to start
    echo "‚è≥ Waiting for services to initialize..."
    sleep 30
    
    # Verify deployment
    verify_services
}

# Run main function with all arguments
main "$@"
