name: üöÄ ATS Server Complete Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'What to deploy'
        required: true
        type: choice
        options:
          - 'full-deploy'          # Deploy both React web app and ATS server
          - 'web-only'             # Deploy only React web interface
          - 'docker-only'          # Deploy only Docker containers
          - 'ats-server-only'      # Deploy only ATS dedicated server
          - 'update-server'        # Update existing deployment
        default: 'docker-only'
      
      create_new_server:
        description: 'Create new Linode server for ATS'
        required: false
        type: boolean
        default: true
      
      server_type:
        description: 'Server type to create'
        required: false
        type: choice
        options:
          - 'g6-standard-1'        # 2GB RAM, 1 CPU (recommended for ATS)
          - 'g6-standard-2'        # 4GB RAM, 1 CPU 
          - 'g6-standard-4'        # 8GB RAM, 2 CPU (for multiple servers)
          - 'g6-standard-8'        # 16GB RAM, 4 CPU (for heavy mod loads)
        default: 'g6-standard-1'
      
      target_region:
        description: 'Linode region for server'
        required: false
        type: choice
        options:
          - 'us-east'              # New York/Newark
          - 'us-central'           # Dallas
          - 'us-west'              # Los Angeles
          - 'ca-central'           # Toronto
          - 'eu-west'              # London
        default: 'ca-central'

env:
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'docker-only' }}
  CREATE_NEW_SERVER: ${{ github.event.inputs.create_new_server || 'true' }}
  SERVER_TYPE: ${{ github.event.inputs.server_type || 'g6-standard-1' }}
  TARGET_REGION: ${{ github.event.inputs.target_region || 'ca-central' }}
  DOMAIN_NAME: ats.7gram.xyz
  NODE_VERSION: '18'
  DOCKER_REPO: nuniesmith/ats
  TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}

jobs:
  # ============================================================================
  # Pre-flight Checks & Validation
  # ============================================================================
  preflight-checks:
    name: üõ´ Pre-flight Checks
    runs-on: ubuntu-latest
    outputs:
      secrets_validated: ${{ steps.validate-secrets.outputs.validated }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîê Validate Required Secrets
        id: validate-secrets
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "üîê Validating required secrets..."
          
          MISSING_SECRETS=()
          
          [[ -z "$LINODE_CLI_TOKEN" ]] && MISSING_SECRETS+=("LINODE_CLI_TOKEN")
          [[ -z "$ATS_ROOT_PASSWORD" ]] && MISSING_SECRETS+=("ATS_ROOT_PASSWORD")
          [[ -z "$TAILSCALE_AUTH_KEY" ]] && MISSING_SECRETS+=("TAILSCALE_AUTH_KEY")
          [[ -z "$JWT_SECRET" ]] && MISSING_SECRETS+=("JWT_SECRET")
          [[ -z "$DOCKER_USERNAME" ]] && MISSING_SECRETS+=("DOCKER_USERNAME")
          [[ -z "$DOCKER_TOKEN" ]] && MISSING_SECRETS+=("DOCKER_TOKEN")
          [[ -z "$CLOUDFLARE_API_TOKEN" ]] && MISSING_SECRETS+=("CLOUDFLARE_API_TOKEN")
          [[ -z "$CLOUDFLARE_ZONE_ID" ]] && MISSING_SECRETS+=("CLOUDFLARE_ZONE_ID")
          
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "‚ùå Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo "validated=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ All required secrets are configured"
            echo "validated=true" >> $GITHUB_OUTPUT
          fi
          
          # Optional secrets check
          OPTIONAL_SECRETS=()
          [[ -z "${{ secrets.DISCORD_WEBHOOK_URL }}" ]] && OPTIONAL_SECRETS+=("DISCORD_WEBHOOK_URL")
          
          if [[ ${#OPTIONAL_SECRETS[@]} -gt 0 ]]; then
            echo "‚ÑπÔ∏è Optional secrets (will disable some features):"
            printf '  - %s\n' "${OPTIONAL_SECRETS[@]}"
          fi

  # ============================================================================
  # Detect File Changes
  # ============================================================================
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    needs: preflight-checks
    if: needs.preflight-checks.outputs.secrets_validated == 'true'
    outputs:
      web-changed: ${{ steps.changes.outputs.web }}
      api-changed: ${{ steps.changes.outputs.api }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check for file changes
        id: changes
        run: |
          # Check if this is a manual trigger or first push
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - building all"
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "workflow=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"
          
          # Check for web changes
          if echo "$CHANGED_FILES" | grep -E '^src/web/|^package.*\.json$' >/dev/null 2>&1; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "üì¶ Web app changes detected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for API changes
          if echo "$CHANGED_FILES" | grep -E '^src/api/|^package.*\.json$' >/dev/null 2>&1; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "üîß API changes detected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Docker/deployment changes
          if echo "$CHANGED_FILES" | grep -E '^docker-compose|Dockerfile|\.dockerignore' >/dev/null 2>&1; then
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "üê≥ Docker changes detected"
          else
            echo "docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for workflow changes
          if echo "$CHANGED_FILES" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
            echo "workflow=true" >> $GITHUB_OUTPUT
            echo "‚öôÔ∏è Workflow changes detected"
          else
            echo "workflow=false" >> $GITHUB_OUTPUT
          fi
          
          # If any changes detected, enable docker builds
          if [[ "$(echo "$CHANGED_FILES" | grep -E '^src/|Dockerfile|docker-compose|\.github/workflows/' | wc -l)" -gt 0 ]]; then
            echo "docker=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Infrastructure Check & Setup
  # ============================================================================
  infrastructure-check:
    name: üèóÔ∏è Infrastructure Check
    runs-on: ubuntu-latest
    needs: [preflight-checks, detect-changes]
    if: needs.preflight-checks.outputs.secrets_validated == 'true'
    outputs:
      server-exists: ${{ steps.check-server.outputs.exists }}
      server-ip: ${{ steps.check-server.outputs.ip }}
      server-status: ${{ steps.check-server.outputs.status }}
      should-create: ${{ steps.decision.outputs.create }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Check Existing Linode Servers
        id: check-server
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
        run: |
          echo "üîç Checking for existing ATS servers..."
          
          # Skip if no Linode token provided
          if [[ -z "$LINODE_CLI_TOKEN" ]]; then
            echo "‚ö†Ô∏è No Linode token provided - skipping server check"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for existing servers using API
          echo "üîç Querying Linode API for existing servers..."
          SERVERS_RESPONSE=$(curl -H "Authorization: Bearer $LINODE_CLI_TOKEN" \
            "https://api.linode.com/v4/linode/instances" 2>/dev/null)
          
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Failed to query Linode API"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Look for ATS server
          SERVER_INFO=$(echo "$SERVERS_RESPONSE" | jq -r '.data[] | select(.label == "ats-server") | "\(.ipv4[0]) \(.status)"' 2>/dev/null)
          
          if [ -n "$SERVER_INFO" ]; then
            SERVER_IP=$(echo "$SERVER_INFO" | awk '{print $1}')
            SERVER_STATUS=$(echo "$SERVER_INFO" | awk '{print $2}')
            
            echo "‚úÖ Found existing ATS server:"
            echo "   Public IP: $SERVER_IP"
            echo "   Status: $SERVER_STATUS"
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "status=$SERVER_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No existing ATS server found"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
          fi

      - name: ü§î Deployment Decision
        id: decision
        run: |
          echo "ü§î Making deployment decisions..."
          
          SERVER_EXISTS="${{ steps.check-server.outputs.exists }}"
          CREATE_NEW="${{ env.CREATE_NEW_SERVER }}"
          DEPLOYMENT_MODE="${{ env.DEPLOYMENT_MODE }}"
          
          echo "Server exists: $SERVER_EXISTS"
          echo "Create new requested: $CREATE_NEW"
          echo "Deployment mode: $DEPLOYMENT_MODE"
          
          if [[ "$SERVER_EXISTS" == "true" ]]; then
            echo "‚úÖ Server exists - will use existing server"
            echo "create=false" >> $GITHUB_OUTPUT
          elif [[ "$CREATE_NEW" == "true" ]]; then
            echo "üî® Will create new server"
            echo "create=true" >> $GITHUB_OUTPUT
          elif [[ "$DEPLOYMENT_MODE" == "docker-only" || "$DEPLOYMENT_MODE" == "full-deploy" || "$DEPLOYMENT_MODE" == "web-only" ]]; then
            echo "üî® Deployment requested but no server exists - will create one"
            echo "create=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No server exists and create_new_server=false"
            echo "create=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Create New Server (if needed)
  # ============================================================================
  create-server:
    name: üî® Create ATS Server
    runs-on: ubuntu-latest
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.should-create == 'true'
    outputs:
      server-ip: ${{ steps.create.outputs.ip }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üî® Create Linode Server
        id: create
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üî® Creating new ATS server..."
          
          # Install Linode CLI
          pip3 install linode-cli
          
          # Configure Linode CLI non-interactively
          mkdir -p ~/.config/linode-cli
          cat > ~/.config/linode-cli/config << EOF
          [DEFAULT]
          token = $LINODE_CLI_TOKEN
          region = ${{ env.TARGET_REGION }}
          type = ${{ env.SERVER_TYPE }}
          image = linode/arch
          authorized_users = 
          EOF
          
          # Set LINODE_CLI_TOKEN environment variable to avoid interactive prompts
          export LINODE_CLI_TOKEN="$LINODE_CLI_TOKEN"
          
          # Create the server using API directly to avoid CLI configuration issues
          echo "üî® Creating server via Linode API..."
          RESULT=$(curl -H "Authorization: Bearer $LINODE_CLI_TOKEN" \
            -H "Content-Type: application/json" \
            -X POST "https://api.linode.com/v4/linode/instances" \
            -d "{
              \"label\": \"ats-server\",
              \"region\": \"${{ env.TARGET_REGION }}\",
              \"type\": \"${{ env.SERVER_TYPE }}\",
              \"image\": \"linode/arch\",
              \"root_pass\": \"$ATS_ROOT_PASSWORD\",
              \"booted\": true
            }")
          
          echo "API Response: $RESULT"
          
          # Extract server IP
          SERVER_IP=$(echo "$RESULT" | jq -r '.ipv4[0]')
          if [[ "$SERVER_IP" == "null" || -z "$SERVER_IP" ]]; then
            echo "‚ùå Failed to create server or extract IP"
            echo "API Response: $RESULT"
            exit 1
          fi
          
          echo "‚úÖ Server created with IP: $SERVER_IP"
          echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
          
          # Wait for server to boot
          echo "‚è≥ Waiting for server to boot..."
          sleep 120

      - name: üîß Stage 1 - Initial Server Setup
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
          NETDATA_CLAIM_TOKEN: ${{ secrets.NETDATA_CLAIM_TOKEN }}
          NETDATA_CLAIM_ROOM: ${{ secrets.NETDATA_CLAIM_ROOM }}
        run: |
          echo "üîß Stage 1: Initial Arch Linux setup..."
          
          # Wait for SSH to be available
          for i in {1..10}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "echo 'Server ready'"; then
              echo "‚úÖ SSH connection established"
              break
            fi
            echo "‚è≥ Waiting for SSH... (attempt $i/10)"
            sleep 30
          done
          
          # Stage 1: System setup and stage 2 service creation
          echo "üîß Setting up environment variables for SSH session..."
          NETDATA_TOKEN_ENV=""
          NETDATA_ROOMS_ENV=""
          
          if [[ -n "$NETDATA_CLAIM_TOKEN" ]]; then
            NETDATA_TOKEN_ENV="export NETDATA_CLAIM_TOKEN='$NETDATA_CLAIM_TOKEN';"
          fi
          
          if [[ -n "$NETDATA_CLAIM_ROOM" ]]; then
            NETDATA_ROOMS_ENV="export NETDATA_CLAIM_ROOM='$NETDATA_CLAIM_ROOM';"
          fi
          
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << EOF
            $NETDATA_TOKEN_ENV
            $NETDATA_ROOMS_ENV
            echo "üîß Stage 1: System initialization..."
            
            # Update system with conflict resolution
            echo "üì¶ Updating system packages..."
            pacman-key --init
            pacman-key --populate archlinux
            pacman -Sy --noconfirm archlinux-keyring
            
            # Handle known conflicts before system update
            echo "üîß Resolving package conflicts..."
            pacman -R --noconfirm linux-firmware-nvidia 2>/dev/null || echo "linux-firmware-nvidia not installed"
            pacman -R --noconfirm gpgme 2>/dev/null || echo "gpgme conflict resolved"
            
            # Now update system
            pacman -Syu --noconfirm --overwrite="*"
            
            # Install essential packages with verification
            echo "üì¶ Installing essential packages..."
            PACKAGES=(curl wget git unzip nginx docker docker-compose)
            for pkg in "${PACKAGES[@]}"; do
              echo "Installing $pkg..."
              pacman -S --noconfirm --needed "$pkg" || echo "Failed to install $pkg, continuing..."
            done
            
            # Install Tailscale
            echo "üì¶ Installing Tailscale..."
            pacman -S --noconfirm tailscale || {
              echo "Installing Tailscale from AUR..."
              curl -fsSL https://tailscale.com/install.sh | sh
            }
            
            # Install Netdata with cloud integration  
            echo "üì¶ Installing Netdata with cloud integration..."
            echo "Installing Netdata manually via kickstart script..."
            curl -fsSL https://get.netdata.cloud/kickstart.sh | sh -s -- --stable-channel --disable-telemetry --claim-token="${NETDATA_CLAIM_TOKEN:-}" --claim-rooms="${NETDATA_CLAIM_ROOM:-}" --claim-url="https://app.netdata.cloud"
            
            # Configure Netdata for cloud access if tokens are provided
            if [[ -n "${NETDATA_CLAIM_TOKEN:-}" && -n "${NETDATA_CLAIM_ROOM:-}" ]]; then
              echo "üîó Configuring Netdata cloud integration..."
              # Create netdata cloud configuration
              mkdir -p /etc/netdata
              cat > /etc/netdata/netdata.conf << 'NETDATAEOF'
          [global]
              hostname = ats-server
              history = 86400
              memory mode = dbengine
              page cache size = 32
              dbengine disk space = 256
          
          [web]
              mode = multi-threaded
              web files owner = root
              web files group = netdata
              bind to = *:19999
              allow connections from = localhost 10.* 192.168.* 172.16.* 172.17.* 172.18.* 172.19.* 172.20.* 172.21.* 172.22.* 172.23.* 172.24.* 172.25.* 172.26.* 172.27.* 172.28.* 172.29.* 172.30.* 172.31.* 100.*
          
          [plugins]
              proc = yes
              diskspace = yes
              cgroups = yes
              tc = no
              idlejitter = yes
              checks = no
              apps = yes
              charts.d = yes
              node.d = yes
              python.d = yes
              go.d = yes
          NETDATAEOF
              
              # Claim the node to Netdata Cloud
              if command -v netdata-claim.sh >/dev/null 2>&1; then
                netdata-claim.sh -token="${NETDATA_CLAIM_TOKEN}" -rooms="${NETDATA_CLAIM_ROOM}" -url="https://app.netdata.cloud"
                echo "‚úÖ Netdata claimed to cloud"
              else
                echo "‚ö†Ô∏è Netdata claim script not found, will retry in Stage 2"
              fi
            else
              echo "‚ÑπÔ∏è Netdata cloud tokens not provided, running in standalone mode"
            fi
            
            # Install Certbot for SSL certificates
            echo "üì¶ Installing Certbot for SSL certificates..."
            pacman -S --noconfirm --needed certbot python-pip || echo "Failed to install certbot from pacman"
            
            # Install DNS Cloudflare plugin via pip (more reliable)
            echo "üì¶ Installing Certbot DNS Cloudflare plugin..."
            pip install --upgrade pip --break-system-packages || echo "Failed to upgrade pip"
            pip install certbot-dns-cloudflare --break-system-packages || {
              echo "Failed to install DNS plugin via pip, trying pacman..."
              pacman -S --noconfirm --needed python-certbot-dns-cloudflare || echo "DNS plugin installation failed, SSL will use self-signed only"
            }
            
            # Configure system optimizations
            echo "‚öôÔ∏è Configuring system optimizations..."
            echo 'vm.overcommit_memory = 1' >> /etc/sysctl.conf
            sysctl vm.overcommit_memory=1
            
            # Verify memory overcommit setting
            echo "üîç Verifying memory overcommit configuration..."
            OVERCOMMIT_VALUE=$(sysctl -n vm.overcommit_memory)
            echo "   Current vm.overcommit_memory value: $OVERCOMMIT_VALUE"
            if [ "$OVERCOMMIT_VALUE" = "1" ]; then
              echo "‚úÖ Memory overcommit properly configured for Redis"
            else
              echo "‚ö†Ô∏è Memory overcommit not set correctly, Redis may show warnings"
            fi
            
            # Set timezone to EST (Toronto, Canada)
            echo "üïê Setting timezone to America/Toronto (EST)..."
            timedatectl set-timezone America/Toronto
            echo "‚úÖ Timezone set to: $(timedatectl show --property=Timezone --value)"
            
            # Verify docker installation and enable service immediately
            if systemctl list-unit-files | grep -q docker.service; then
              echo "‚úÖ Docker service found, enabling..."
              systemctl enable docker
            else
              echo "‚ùå Docker service not found after installation"
              pacman -S --noconfirm docker
              systemctl enable docker
            fi
            
            # Verify docker-compose installation
            if ! command -v docker-compose >/dev/null 2>&1; then
              echo "Installing docker-compose via pacman..."
              pacman -S --noconfirm --needed docker-compose || {
                echo "Installing docker-compose via pip as fallback..."
                pacman -S --noconfirm python-pip
                pip install docker-compose --break-system-packages || echo "docker-compose installation failed"
              }
            fi
            
            # Enable essential services
            systemctl enable docker
            systemctl enable tailscaled
            systemctl enable netdata
            
            # Create stage 2 deployment script
            cat > /opt/ats-stage2-deploy.sh << 'STAGE2_SCRIPT'
          #!/bin/bash
          echo "üöÄ Stage 2: Post-reboot deployment with Tailscale..."
          
          # Start Tailscale and authenticate
          systemctl start tailscaled
          sleep 5
          
          # Authenticate with Tailscale (using authkey from environment)
          if [ -n "\$TAILSCALE_AUTH_KEY" ]; then
            tailscale up --authkey="\$TAILSCALE_AUTH_KEY" --accept-routes --hostname=ats
            echo "‚úÖ Tailscale authentication completed with hostname 'ats'"
          else
            echo "‚ö†Ô∏è No Tailscale authkey provided, skipping Tailscale setup"
          fi
          
          # Set hostname to match domain
          hostnamectl set-hostname ats
          echo "127.0.0.1 ats ats.7gram.xyz" >> /etc/hosts
          echo "‚úÖ Hostname set to 'ats'"
          
          # Verify timezone setting
          echo "üïê Verifying timezone configuration..."
          echo "   Current timezone: $(timedatectl show --property=Timezone --value)"
          echo "   Current time: $(date)"
          
          # Start Docker
          systemctl start docker
          systemctl enable docker
          
          # Wait for Docker to be ready with error handling
          DOCKER_READY=false
          for i in {1..30}; do
            if docker info >/dev/null 2>&1; then
              echo "‚úÖ Docker daemon is ready"
              DOCKER_READY=true
              break
            fi
            echo "‚è≥ Waiting for Docker daemon... (attempt \$i/30)"
            
            # Try to restart Docker if it's taking too long
            if [ \$i -eq 15 ]; then
              echo "üîÑ Restarting Docker service..."
              systemctl restart docker
              sleep 5
            fi
            
            sleep 3
          done
          
          if [ "\$DOCKER_READY" != "true" ]; then
            echo "‚ùå Docker failed to start in Stage 2"
            systemctl status docker --no-pager || echo "Docker service status unavailable"
            journalctl -u docker --no-pager -n 10 || echo "Docker logs unavailable"
          else
            echo "‚úÖ Docker successfully started in Stage 2"
          fi
          
          # Verify docker-compose is available
          if ! command -v docker-compose >/dev/null 2>&1; then
            echo "Installing docker-compose..."
            pacman -S --noconfirm docker-compose || pip install docker-compose
          fi
          echo "‚úÖ Docker and docker-compose ready"
          
          # Start and configure Netdata with cloud integration
          echo "üìä Starting Netdata monitoring..."
          systemctl start netdata
          
          # Retry cloud claiming if not done in Stage 1
          if [[ -n "\$NETDATA_CLAIM_TOKEN" && -n "\$NETDATA_CLAIM_ROOM" ]]; then
            echo "üîó Attempting Netdata cloud claim..."
            if command -v netdata-claim.sh >/dev/null 2>&1; then
              netdata-claim.sh -token="\$NETDATA_CLAIM_TOKEN" -rooms="\$NETDATA_CLAIM_ROOM" -url="https://app.netdata.cloud" || echo "‚ö†Ô∏è Netdata cloud claim failed, check tokens"
            elif [[ -f /usr/libexec/netdata/netdata-claim.sh ]]; then
              /usr/libexec/netdata/netdata-claim.sh -token="\$NETDATA_CLAIM_TOKEN" -rooms="\$NETDATA_CLAIM_ROOM" -url="https://app.netdata.cloud" || echo "‚ö†Ô∏è Netdata cloud claim failed, check tokens"
            else
              echo "‚ö†Ô∏è Netdata claim script not found"
            fi
            
            # Restart Netdata after claiming
            systemctl restart netdata
            sleep 5
          fi
          
          echo "‚úÖ Netdata monitoring started on port 19999"
          echo "üåê Netdata will be available at: http://\$(hostname -I 2>/dev/null | awk '{print \$1}' || ip route get 1 | awk '{print \$7; exit}'):19999"
          
          if [[ -n "\$NETDATA_CLAIM_TOKEN" ]]; then
            echo "‚òÅÔ∏è Netdata cloud integration configured - check https://app.netdata.cloud"
          fi
          
          # Configure firewall for Arch Linux
          if command -v ufw >/dev/null 2>&1; then
            ufw allow ssh
            ufw allow http
            ufw allow https
            ufw allow 19999
            ufw --force enable
          else
            # Configure iptables for Arch
            iptables -A INPUT -i lo -j ACCEPT
            iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
            iptables -A INPUT -p tcp --dport 22 -j ACCEPT
            iptables -A INPUT -p tcp --dport 80 -j ACCEPT
            iptables -A INPUT -p tcp --dport 443 -j ACCEPT
            iptables -A INPUT -p tcp --dport 3001 -j ACCEPT
            iptables -A INPUT -p tcp --dport 19999 -j ACCEPT
            iptables -A INPUT -j DROP
            
            # Save iptables rules
            mkdir -p /etc/iptables
            iptables-save > /etc/iptables/iptables.rules
            systemctl enable iptables
          fi
          
          # Create deployment directory
          mkdir -p /opt/ats
          
          echo "‚úÖ Stage 2 setup completed - ready for deployment"
          
          # Signal completion
          touch /opt/stage2-complete
          STAGE2_SCRIPT
            
            chmod +x /opt/ats-stage2-deploy.sh
            
            # Create systemd service for stage 2
            cat > /etc/systemd/system/ats-stage2.service << 'SERVICE_FILE'
          [Unit]
          Description=ATS Stage 2 Deployment
          After=network.target
          Wants=network.target
          
          [Service]
          Type=oneshot
          Environment=TAILSCALE_AUTH_KEY=\$TAILSCALE_AUTH_KEY
          Environment=NETDATA_CLAIM_TOKEN=\$NETDATA_CLAIM_TOKEN
          Environment=NETDATA_CLAIM_ROOM=\$NETDATA_CLAIM_ROOM
          ExecStart=/opt/ats-stage2-deploy.sh
          RemainAfterExit=yes
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          SERVICE_FILE
            
            # Enable stage 2 service
            systemctl enable ats-stage2.service
            
            echo "‚úÖ Stage 1 complete - systemd service created for stage 2"
            echo "üîÑ Preparing for reboot..."
          EOF
          
          # Set Tailscale authkey in the service environment
          if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
              "if [ -f /etc/systemd/system/ats-stage2.service ]; then sed -i 's/\\\\$TAILSCALE_AUTH_KEY/$TAILSCALE_AUTH_KEY/' /etc/systemd/system/ats-stage2.service; else echo 'Service file not found for Tailscale authkey update'; fi"
          fi
          
          # Set Netdata environment variables in the service
          if [[ -n "$NETDATA_CLAIM_TOKEN" ]]; then
            sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
              "if [ -f /etc/systemd/system/ats-stage2.service ]; then sed -i 's/\\\\$NETDATA_CLAIM_TOKEN/$NETDATA_CLAIM_TOKEN/' /etc/systemd/system/ats-stage2.service; else echo 'Service file not found for Netdata token update'; fi"
          fi
          
          if [[ -n "$NETDATA_CLAIM_ROOM" ]]; then
            sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
              "if [ -f /etc/systemd/system/ats-stage2.service ]; then sed -i 's/\\\\$NETDATA_CLAIM_ROOM/$NETDATA_CLAIM_ROOM/' /etc/systemd/system/ats-stage2.service; else echo 'Service file not found for Netdata rooms update'; fi"
          fi
          
          # Reload systemd and reboot
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
            "systemctl daemon-reload && reboot" || true
          
          echo "üîÑ Server rebooting for stage 2..."

      - name: ‚è≥ Wait for Stage 2 Completion
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "‚è≥ Waiting for server reboot and stage 2 completion..."
          
          # Wait for reboot
          sleep 60
          
          # Wait for SSH to come back up and stage 2 to complete
          for i in {1..20}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "test -f /opt/stage2-complete"; then
              echo "‚úÖ Stage 2 deployment completed successfully"
              break
            fi
            echo "‚è≥ Waiting for stage 2 completion... (attempt $i/20)"
            sleep 30
          done
          
          # Verify services are running
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "üîç Verifying services..."
            systemctl status docker --no-pager
            
            if systemctl list-unit-files | grep -q tailscaled.service; then
              systemctl status tailscaled --no-pager
              # Check Tailscale status
              if command -v tailscale >/dev/null 2>&1; then
                tailscale status || echo "‚ö†Ô∏è Tailscale not connected"
              else
                echo "‚ö†Ô∏è Tailscale command not found"
              fi
            else
              echo "‚ö†Ô∏è Tailscale service not installed"
            fi
            
            if systemctl list-unit-files | grep -q netdata.service; then
              systemctl status netdata --no-pager
            else
              echo "‚ö†Ô∏è Netdata service not installed"
            fi
            
            echo "‚úÖ Two-stage deployment completed"
            echo "üìä Netdata monitoring available at: http://$(hostname -I 2>/dev/null | awk '{print $1}' || ip route get 1 | awk '{print $7; exit}'):19999"
          EOF

  # ============================================================================
  # Build and Push Docker Images to DockerHub
  # ============================================================================
  build-docker-images:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
       (needs.detect-changes.outputs.docker-changed == 'true' || 
        needs.detect-changes.outputs.web-changed == 'true' || 
        needs.detect-changes.outputs.api-changed == 'true' ||
        github.event_name == 'workflow_dispatch'))
    outputs:
      web-image: ${{ steps.meta.outputs.web-image }}
      api-image: ${{ steps.meta.outputs.api-image }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üè∑Ô∏è Generate image tags
        id: meta
        run: |
          # Generate version tag
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="latest"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="pr-${{ github.event.number }}"
          fi
          
          WEB_IMAGE="${{ env.DOCKER_REPO }}:web-${VERSION}"
          API_IMAGE="${{ env.DOCKER_REPO }}:api-${VERSION}"
          
          echo "web-image=${WEB_IMAGE}" >> $GITHUB_OUTPUT
          echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Will build:"
          echo "  Web: ${WEB_IMAGE}"
          echo "  API: ${API_IMAGE}"

      - name: üèóÔ∏è Build and Push React Web App
        if: needs.detect-changes.outputs.web-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/web
          file: ./src/web/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.web-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_API_URL=http://localhost/api
            VITE_SOCKET_URL=http://localhost

      - name: üèóÔ∏è Build and Push API Server
        if: needs.detect-changes.outputs.api-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/api
          file: ./src/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.api-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy-to-server:
    name: üöÄ Deploy to ATS Server
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, create-server, detect-changes]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
      (needs.build-docker-images.result == 'success' || needs.build-docker-images.result == 'skipped')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üéØ Determine Target Server
        id: target
        run: |
          if [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
            echo "Using existing server: $SERVER_IP"
          elif [[ "${{ needs.create-server.result }}" == "success" ]]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
            echo "Using new server: $SERVER_IP"
          else
            echo "‚ùå No server available for deployment"
            exit 1
          fi
          echo "server-ip=$SERVER_IP" >> $GITHUB_OUTPUT

      - name: ÔøΩ Verify Server Readiness
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üîç Verifying server readiness before deployment..."
          
          # Check if Stage 2 completed (for new servers)
          if [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "üìã Checking Stage 2 completion status..."
            STAGE2_STATUS=$(sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
              if [ -f /opt/stage2-complete ]; then
                echo 'completed'
              else
                echo 'incomplete'
              fi
            ")
            
            if [[ "$STAGE2_STATUS" == "completed" ]]; then
              echo "‚úÖ Stage 2 completed successfully"
            else
              echo "‚ö†Ô∏è Stage 2 may not have completed properly"
              echo "üìä Checking system status:"
              
              sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
                echo 'System uptime:'
                uptime
                echo 'Available services:'
                systemctl list-units --type=service --state=active | grep -E 'docker|tailscale|netdata' || echo 'No matching services found'
                echo 'Docker status:'
                systemctl status docker --no-pager || echo 'Docker service not found'
              "
            fi
          fi
          
          # Verify basic connectivity and system status
          echo "üåê Checking server connectivity and basic status..."
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
            echo 'Hostname: \$(hostname)'
            echo 'System: \$(uname -a)'
            echo 'Available disk space:'
            df -h /
            echo 'Memory usage:'
            free -h
            echo 'Network interfaces:'
            ip addr show | grep -E 'inet [0-9]' | grep -v '127.0.0.1' | awk '{print \$2}' | head -3
          "

      - name: ÔøΩüì¶ Deploy Docker Stack
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          WEB_IMAGE: ${{ needs.build-docker-images.outputs.web-image }}
          API_IMAGE: ${{ needs.build-docker-images.outputs.api-image }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üöÄ Deploying to server: $SERVER_IP"
          echo "üê≥ Using images:"
          echo "   Web: ${WEB_IMAGE:-nuniesmith/ats:web-latest}"
          echo "   API: ${API_IMAGE:-nuniesmith/ats:api-latest}"
          
          # Create deployment directory and subdirectories
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "mkdir -p /opt/ats/config /opt/ats/scripts"
          
          # Copy deployment files and scripts
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@$SERVER_IP:/opt/ats/docker-compose.yml
          
          # Copy nginx configurations
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/nginx.conf root@$SERVER_IP:/opt/ats/config/nginx.conf
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/nginx-with-ssl.conf root@$SERVER_IP:/opt/ats/config/nginx-with-ssl.conf
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/nginx-http-only.conf root@$SERVER_IP:/opt/ats/config/nginx-http-only.conf
          
          # Copy SSL management scripts and services
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no scripts/ssl-manager.sh root@$SERVER_IP:/opt/ats/scripts/ssl-manager.sh
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/ats-ssl-manager.service root@$SERVER_IP:/etc/systemd/system/ats-ssl-manager.service
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/ats-ssl-renewal.service root@$SERVER_IP:/etc/systemd/system/ats-ssl-renewal.service
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/ats-ssl-renewal.timer root@$SERVER_IP:/etc/systemd/system/ats-ssl-renewal.timer
          
          # Create environment file
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "cat > /opt/ats/.env << 'EOF'
          NODE_ENV=production
          TZ=America/Toronto
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ env.DOMAIN_NAME }}
          ATS_DEFAULT_PASSWORD=${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID=3530633316
          WEB_IMAGE=${WEB_IMAGE:-nuniesmith/ats:web-latest}
          API_IMAGE=${API_IMAGE:-nuniesmith/ats:api-latest}
          CLOUDFLARE_API_TOKEN=${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID=${{ secrets.CLOUDFLARE_ZONE_ID }}
          DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }}
          EOF"
          
          # Deploy the stack
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /opt/ats
            
            # Ensure Docker is properly installed and configured
            echo 'üîß Checking Docker installation...'
            if ! command -v docker >/dev/null 2>&1; then
              echo 'Docker not found, installing...'
              pacman -Syu --noconfirm
              pacman -S --noconfirm docker docker-compose
            fi
            
            # Ensure Docker daemon is running
            echo 'Starting Docker daemon...'
            systemctl start docker
            systemctl enable docker
            
            # Wait for Docker daemon to be ready with better error handling
            DOCKER_READY=false
            for i in {1..30}; do
              if docker info >/dev/null 2>&1; then
                echo 'Docker daemon is ready'
                DOCKER_READY=true
                break
              fi
              echo \"Waiting for Docker daemon... (attempt \$i/30)\"
              
              # Try to restart Docker service if it's not responding
              if [ \$i -eq 10 ] || [ \$i -eq 20 ]; then
                echo 'Restarting Docker service...'
                systemctl stop docker 2>/dev/null || true
                sleep 2
                systemctl start docker
                sleep 5
              fi
              
              sleep 3
            done
            
            if [ \"\$DOCKER_READY\" != \"true\" ]; then
              echo '‚ùå Docker daemon failed to start after 30 attempts'
              echo 'Checking Docker service status:'
              systemctl status docker --no-pager || true
              echo 'Checking Docker logs:'
              journalctl -u docker --no-pager -n 20 || true
              exit 1
            fi
            
            # Check if docker-compose is available, install if not
            if ! command -v docker-compose >/dev/null 2>&1; then
              echo 'Installing docker-compose...'
              pacman -S --noconfirm docker-compose || pip install docker-compose
            fi
            
            # Verify Docker is working
            echo 'üîç Verifying Docker installation:'
            docker version
            docker-compose version
            
            # Verify system configuration for Redis
            echo 'üîç Verifying system configuration for Redis:'
            echo \"   Memory overcommit: \$(sysctl -n vm.overcommit_memory)\"
            echo \"   Available memory: \$(free -h | grep Mem | awk '{print \$2}')\"
            echo \"   Swap status: \$(free -h | grep Swap | awk '{print \$2}')\"
            
            # Set up SSL certificates before starting containers
            echo 'üîí Setting up SSL certificates...'
            chmod +x scripts/ssl-manager.sh
            
            # Create Cloudflare credentials if token is provided
            if [[ -n '$CLOUDFLARE_API_TOKEN' ]]; then
              mkdir -p /root/.secrets
              cat > /root/.secrets/cloudflare.ini << 'CFEOF'
          dns_cloudflare_api_token = $CLOUDFLARE_API_TOKEN
          CFEOF
              chmod 600 /root/.secrets/cloudflare.ini
              echo '‚úÖ Cloudflare credentials configured'
            fi
            
            # Backup original SSL nginx config and start with HTTP-only
            echo 'üîß Setting up initial HTTP-only nginx configuration...'
            cp config/nginx.conf config/nginx-ssl.conf.backup
            cp config/nginx-http-only.conf config/nginx.conf
            
            # Pull and start containers with HTTP-only config
            echo 'Pulling Docker images...'
            docker-compose pull
            
            echo 'Starting containers (HTTP-only initially)...'
            docker-compose up -d
            
            # Wait for containers to be ready
            echo 'Waiting for containers to start...'
            sleep 10
            
            # Run SSL manager to set up certificates
            echo 'üîí Setting up SSL certificates...'
            ./scripts/ssl-manager.sh auto
            
            # Now switch to SSL configuration and restart nginx
            echo 'üîÑ Switching to SSL configuration...'
            if [[ -f /etc/letsencrypt/live/ats.7gram.xyz/fullchain.pem ]]; then
              echo '‚úÖ SSL certificates found, enabling HTTPS'
              cp config/nginx-ssl.conf.backup config/nginx.conf
              docker-compose restart nginx
            else
              echo '‚ö†Ô∏è No SSL certificates, staying with HTTP-only'
            fi
            
            # Enable SSL management services
            echo '‚öôÔ∏è Setting up SSL management services...'
            systemctl daemon-reload
            systemctl enable ats-ssl-manager.service
            systemctl enable ats-ssl-renewal.timer
            systemctl start ats-ssl-renewal.timer
            
            # Show container status
            echo 'üìä Container status:'
            docker-compose ps
            
            echo 'üìù Recent container logs:'
            docker-compose logs --tail=20
            
            # Test Redis functionality
            echo 'üîç Testing Redis functionality...'
            if docker exec ats-redis redis-cli ping >/dev/null 2>&1; then
              echo '‚úÖ Redis is responding to ping'
              echo 'üìä Redis info:'
              docker exec ats-redis redis-cli info server | grep redis_version || echo 'Could not get Redis version'
              echo 'üîç Checking Redis logs for memory overcommit warnings...'
              REDIS_LOGS=$(docker logs ats-redis 2>&1 | grep -i "memory overcommit" | tail -3 || echo "No memory overcommit warnings found")
              echo "   Redis memory overcommit status: $REDIS_LOGS"
            else
              echo '‚ö†Ô∏è Redis is not responding to ping'
              docker logs ats-redis --tail=10
            fi
            
            # Test container connectivity
            echo 'üîó Testing container network connectivity...'
            if docker exec ats-web-app nslookup ats-api-server >/dev/null 2>&1; then
              echo '‚úÖ Web app can resolve API server'
            else
              echo '‚ö†Ô∏è Web app cannot resolve API server - checking network'
              docker network ls
              docker network inspect ats-network || docker network inspect ats_ats-network
            fi
            
            # Wait for health checks
            echo 'Waiting for services to be healthy...'
            for i in {1..6}; do
              if curl -f http://localhost/nginx-health >/dev/null 2>&1; then
                echo 'HTTP health check passed'
                break
              fi
              echo \"Waiting for HTTP access... (attempt \$i/6)\"
              sleep 5
            done
            
            for i in {1..6}; do
              if curl -k -f https://localhost/nginx-health >/dev/null 2>&1; then
                echo 'HTTPS health check passed'
                break
              fi
              echo \"Waiting for HTTPS access... (attempt \$i/6)\"
              sleep 5
            done
          "

      - name: üîó Verify Tailscale Connection
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üîó Verifying Tailscale connection..."
          
          # Check Tailscale status and get internal IP
          TAILSCALE_STATUS=$(sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "tailscale status --json 2>/dev/null || echo '{}'")
          
          if echo "$TAILSCALE_STATUS" | jq -e '.Self.Online' >/dev/null 2>&1; then
            TAILSCALE_IP=$(echo "$TAILSCALE_STATUS" | jq -r '.Self.TailscaleIPs[0] // "unknown"')
            echo "‚úÖ Tailscale connected successfully"
            echo "   Public IP: $SERVER_IP"
            echo "   Tailscale IP: $TAILSCALE_IP"
            echo "   Hostname: ats"
            echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_ENV
            echo "TAILSCALE_IP=$TAILSCALE_IP" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Tailscale not connected or authentication failed"
            echo "Attempting manual Tailscale authentication..."
            
            # Retry Tailscale authentication if failed
            if [[ -n "${{ secrets.TAILSCALE_AUTH_KEY }}" ]]; then
              sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
                systemctl restart tailscaled
                sleep 10
                tailscale up --authkey='${{ secrets.TAILSCALE_AUTH_KEY }}' --accept-routes --hostname=ats --force-reauth
                sleep 5
                tailscale status
              "
              
              # Re-check Tailscale status after retry
              echo "üîÑ Re-checking Tailscale status after retry..."
              TAILSCALE_STATUS_RETRY=$(sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "tailscale status --json 2>/dev/null || echo '{}'")
              
              if echo "$TAILSCALE_STATUS_RETRY" | jq -e '.Self.Online' >/dev/null 2>&1; then
                TAILSCALE_IP=$(echo "$TAILSCALE_STATUS_RETRY" | jq -r '.Self.TailscaleIPs[0] // "unknown"')
                echo "‚úÖ Tailscale authentication successful after retry"
                echo "   Tailscale IP: $TAILSCALE_IP"
                echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_ENV
                echo "TAILSCALE_IP=$TAILSCALE_IP" >> $GITHUB_ENV
              else
                echo "‚ùå Tailscale authentication failed after retry"
                echo "TAILSCALE_IP=" >> $GITHUB_ENV
              fi
            else
              echo "‚ùå No Tailscale auth key provided"
              echo "TAILSCALE_IP=" >> $GITHUB_ENV
            fi
          fi

      - name: üåê Update Cloudflare DNS Records
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          TAILSCALE_IP: ${{ env.TAILSCALE_IP }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          DOMAIN_NAME: ${{ env.DOMAIN_NAME }}
        run: |
          if [[ -n "$CLOUDFLARE_API_TOKEN" && -n "$CLOUDFLARE_ZONE_ID" && -n "$DOMAIN_NAME" ]]; then
            echo "üåê Updating Cloudflare DNS records for $DOMAIN_NAME..."
            
            # Determine which IP to use for DNS records
            if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "" ]]; then
              DNS_IP="$TAILSCALE_IP"
              echo "üîó Using Tailscale IP for DNS records: $DNS_IP"
            else
              DNS_IP="$SERVER_IP"
              echo "‚ö†Ô∏è Tailscale IP not available, falling back to public IP: $DNS_IP"
            fi
            
            # Function to update DNS record
            update_dns_record() {
              local record_name="$1"
              local record_ip="$2"
              local record_type="${3:-A}"
              
              echo "üîÑ Updating $record_type record: $record_name -> $record_ip"
              
              # Get existing record ID
              RECORD_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$record_name&type=$record_type" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json")
              
              RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id // "null"')
              
              if [[ "$RECORD_ID" != "null" && "$RECORD_ID" != "" ]]; then
                # Update existing record
                UPDATE_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
                  -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                  -H "Content-Type: application/json" \
                  --data "{\"type\":\"$record_type\",\"name\":\"$record_name\",\"content\":\"$record_ip\",\"ttl\":1}")
                
                if echo "$UPDATE_RESPONSE" | jq -e '.success' >/dev/null; then
                  echo "‚úÖ Updated $record_name ($record_type) -> $record_ip"
                else
                  echo "‚ùå Failed to update $record_name: $(echo "$UPDATE_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')"
                fi
              else
                # Create new record
                CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
                  -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                  -H "Content-Type: application/json" \
                  --data "{\"type\":\"$record_type\",\"name\":\"$record_name\",\"content\":\"$record_ip\",\"ttl\":1}")
                
                if echo "$CREATE_RESPONSE" | jq -e '.success' >/dev/null; then
                  echo "‚úÖ Created $record_name ($record_type) -> $record_ip"
                else
                  echo "‚ùå Failed to create $record_name: $(echo "$CREATE_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')"
                fi
              fi
            }
            
            # Update main domain A record with Tailscale IP
            update_dns_record "$DOMAIN_NAME" "$DNS_IP" "A"
            
            # Update www subdomain with Tailscale IP
            update_dns_record "www.$DOMAIN_NAME" "$DNS_IP" "A"
            
            # Update API subdomain with Tailscale IP
            update_dns_record "api.$DOMAIN_NAME" "$DNS_IP" "A"
            
            echo "üåê DNS update completed"
            if [[ "$DNS_IP" == "$TAILSCALE_IP" ]]; then
              echo "   üîó All DNS records updated with Tailscale IP: $DNS_IP"
              echo "   Main domain: https://$DOMAIN_NAME (Tailscale)"
              echo "   WWW: https://www.$DOMAIN_NAME (Tailscale)"
              echo "   API: https://api.$DOMAIN_NAME (Tailscale)"
              echo ""
              echo "   ‚ÑπÔ∏è Note: These domains will only resolve within your Tailscale network"
              echo "   üåç Public access still available at: http://$SERVER_IP"
            else
              echo "   üåç DNS records updated with public IP: $DNS_IP"
              echo "   Main domain: https://$DOMAIN_NAME"
              echo "   WWW: https://www.$DOMAIN_NAME"
              echo "   API: https://api.$DOMAIN_NAME"
            fi
            
            # Wait for DNS propagation
            echo "‚è≥ Waiting 30 seconds for DNS propagation..."
            sleep 30
            
          else
            echo "‚ÑπÔ∏è Cloudflare credentials not configured, skipping DNS update"
            echo "  CLOUDFLARE_API_TOKEN: $([[ -n "$CLOUDFLARE_API_TOKEN" ]] && echo "‚úÖ Set" || echo "‚ùå Missing")"
            echo "  CLOUDFLARE_ZONE_ID: $([[ -n "$CLOUDFLARE_ZONE_ID" ]] && echo "‚úÖ Set" || echo "‚ùå Missing")"
            echo "  DOMAIN_NAME: $([[ -n "$DOMAIN_NAME" ]] && echo "‚úÖ Set ($DOMAIN_NAME)" || echo "‚ùå Missing")"
          fi

  # ============================================================================
  # Deployment Summary & Notifications
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, deploy-to-server, create-server, detect-changes]
    if: always()
    steps:
      - name: üìã Generate Summary
        run: |
          echo "# üöÄ ATS Server Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Server status
          if [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "‚úÖ **New Server Created**: ${{ needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            echo "‚úÖ **Using Existing Server**: ${{ needs.infrastructure-check.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.create-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Server Creation Skipped**: No server exists and create_new_server=false" >> $GITHUB_STEP_SUMMARY
            echo "   - To deploy, set create_new_server=true in workflow inputs" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.result }}" == "failure" ]]; then
            echo "‚ùå **Infrastructure Check Failed**: Could not check for existing servers" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Build status
          if [[ "${{ needs.build-docker-images.result }}" == "success" ]]; then
            echo "‚úÖ **Docker Images Built and Pushed**" >> $GITHUB_STEP_SUMMARY
            echo "   - Web: ${{ needs.build-docker-images.outputs.web-image }}" >> $GITHUB_STEP_SUMMARY
            echo "   - API: ${{ needs.build-docker-images.outputs.api-image }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.build-docker-images.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Docker Build Skipped**: No code changes detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Deployment status
          if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
            echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê Access Points" >> $GITHUB_STEP_SUMMARY
            echo "- **Web Interface**: http://${{ env.DOMAIN_NAME }} (Tailscale network)" >> $GITHUB_STEP_SUMMARY
            echo "- **API Server**: http://${{ env.DOMAIN_NAME }}:3001 (Tailscale network)" >> $GITHUB_STEP_SUMMARY
            echo "- **Direct Public Access**: http://${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Netdata Monitoring**: http://${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}:19999" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üîó Network Information" >> $GITHUB_STEP_SUMMARY
            echo "- **Public IP**: ${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Tailscale IP**: Used for DNS records (private network)" >> $GITHUB_STEP_SUMMARY
            echo "- **Hostname**: ats" >> $GITHUB_STEP_SUMMARY
            echo "- **DNS**: Updated for ${{ env.DOMAIN_NAME }} (points to Tailscale IP)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ‚ÑπÔ∏è **Important Notes**" >> $GITHUB_STEP_SUMMARY
            echo "- Domain names resolve to Tailscale IP (private network only)" >> $GITHUB_STEP_SUMMARY
            echo "- Use public IP for access outside Tailscale network" >> $GITHUB_STEP_SUMMARY
            echo "- Tailscale provides secure private network access" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-to-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Deployment Skipped**: No server available" >> $GITHUB_STEP_SUMMARY
            echo "   - Create a server first by setting create_new_server=true" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì¢ Discord Notification
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          SERVER_IP: ${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}
        run: |
          if [[ -n "$DISCORD_WEBHOOK_URL" ]]; then
            echo "üì¢ Sending Discord notification..."
            
            # Determine overall status
            if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
              STATUS="‚úÖ Success"
              COLOR=3066993  # Green
              DESCRIPTION="ATS Server deployment completed successfully!"
            elif [[ "${{ needs.create-server.result }}" == "success" && "${{ needs.deploy-to-server.result }}" != "success" ]]; then
              STATUS="‚ö†Ô∏è Partial Success"
              COLOR=16776960  # Yellow
              DESCRIPTION="Server created but deployment had issues"
            else
              STATUS="‚ùå Failed"
              COLOR=15158332  # Red
              DESCRIPTION="Deployment failed - check logs for details"
            fi
            
            # Create Discord embed
            EMBED_DATA=$(cat <<EOF
          {
            "embeds": [{
              "title": "üöÄ ATS Server Deployment",
              "description": "$DESCRIPTION",
              "color": $COLOR,
              "fields": [
                {
                  "name": "üéØ Status",
                  "value": "$STATUS",
                  "inline": true
                },
                {
                  "name": "üåê Domain",
                  "value": "${{ env.DOMAIN_NAME }}",
                  "inline": true
                },
                {
                  "name": "üìç Server IP",
                  "value": "$SERVER_IP",
                  "inline": true
                },
                {
                  "name": "üîó Access Points",
                  "value": "‚Ä¢ [Web App](http://${{ env.DOMAIN_NAME }}) (Tailscale)\n‚Ä¢ [API](http://${{ env.DOMAIN_NAME }}:3001) (Tailscale)\n‚Ä¢ [Public Access](http://$SERVER_IP)\n‚Ä¢ [Monitoring](http://$SERVER_IP:19999)",
                  "inline": false
                },
                {
                  "name": "üìä Deployment Info",
                  "value": "‚Ä¢ Commit: \`${{ github.sha }}\`\n‚Ä¢ Branch: \`${{ github.ref_name }}\`\n‚Ä¢ Triggered by: ${{ github.event_name }}",
                  "inline": false
                }
              ],
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "footer": {
                "text": "ATS Deployment Pipeline"
              }
            }]
          }
          EOF
            )
            
            # Send to Discord
            curl -H "Content-Type: application/json" \
              -d "$EMBED_DATA" \
              "$DISCORD_WEBHOOK_URL"
            
            echo "‚úÖ Discord notification sent"
          else
            echo "‚ÑπÔ∏è Discord webhook not configured, skipping notification"
          fi

  # ============================================================================
  # Cleanup Failed Deployments
  # ============================================================================
  cleanup-failed-deployment:
    name: üßπ Cleanup Failed Deployment
    runs-on: ubuntu-latest
    needs: [create-server, deploy-to-server]
    if: |
      always() && 
      (needs.create-server.result == 'failure' || 
       (needs.create-server.result == 'success' && needs.deploy-to-server.result == 'failure'))
    steps:
      - name: üßπ Cleanup Failed Server
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
        run: |
          echo "üßπ Cleaning up failed deployment..."
          
          if [[ -n "$LINODE_CLI_TOKEN" ]]; then
            # Get the server ID for cleanup
            if [[ "${{ needs.create-server.result }}" == "success" ]]; then
              SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
              echo "üîç Looking for server with IP: $SERVER_IP"
              
              # Find server by IP and delete it
              SERVERS_RESPONSE=$(curl -s -H "Authorization: Bearer $LINODE_CLI_TOKEN" \
                "https://api.linode.com/v4/linode/instances")
              
              SERVER_ID=$(echo "$SERVERS_RESPONSE" | jq -r ".data[] | select(.ipv4[]? == \"$SERVER_IP\") | .id")
              
              if [[ -n "$SERVER_ID" && "$SERVER_ID" != "null" ]]; then
                echo "üóëÔ∏è Deleting failed server (ID: $SERVER_ID, IP: $SERVER_IP)..."
                
                DELETE_RESPONSE=$(curl -s -X DELETE \
                  -H "Authorization: Bearer $LINODE_CLI_TOKEN" \
                  "https://api.linode.com/v4/linode/instances/$SERVER_ID")
                
                if [[ $? -eq 0 ]]; then
                  echo "‚úÖ Server cleanup completed"
                  echo "üí∞ Server costs stopped - no charges for failed deployment"
                else
                  echo "‚ùå Failed to delete server - please manually cleanup server ID: $SERVER_ID"
                  echo "üîó Manual cleanup: https://cloud.linode.com/linodes/$SERVER_ID"
                fi
              else
                echo "‚ö†Ô∏è Could not find server to cleanup"
              fi
            else
              echo "‚ÑπÔ∏è No server was created, nothing to cleanup"
            fi
          else
            echo "‚ö†Ô∏è No Linode token available for cleanup"
          fi
          
          echo "üîî Deployment failed - check logs above for details"
