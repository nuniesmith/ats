name: üöÄ ATS Server Complete Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'What to deploy'
        required: true
        type: choice
        options:
          - 'full-deploy'          # Deploy both React web app and ATS server
          - 'web-only'             # Deploy only React web interface
          - 'docker-only'          # Deploy only Docker containers
          - 'ats-server-only'      # Deploy only ATS dedicated server
          - 'update-server'        # Update existing deployment
        default: 'docker-only'
      
      create_new_server:
        description: 'Create new Linode server for ATS'
        required: false
        type: boolean
        default: true
      
      server_type:
        description: 'Server type to create'
        required: false
        type: choice
        options:
          - 'g6-standard-1'        # 2GB RAM, 1 CPU (recommended for ATS)
          - 'g6-standard-2'        # 4GB RAM, 1 CPU 
          - 'g6-standard-4'        # 8GB RAM, 2 CPU (for multiple servers)
          - 'g6-standard-8'        # 16GB RAM, 4 CPU (for heavy mod loads)
        default: 'g6-standard-1'
      
      target_region:
        description: 'Linode region for server'
        required: false
        type: choice
        options:
          - 'us-east'              # New York/Newark
          - 'us-central'           # Dallas
          - 'us-west'              # Los Angeles
          - 'ca-central'           # Toronto
          - 'eu-west'              # London
        default: 'ca-central'

env:
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'docker-only' }}
  CREATE_NEW_SERVER: ${{ github.event.inputs.create_new_server || 'true' }}
  SERVER_TYPE: ${{ github.event.inputs.server_type || 'g6-standard-1' }}
  TARGET_REGION: ${{ github.event.inputs.target_region || 'ca-central' }}
  DOMAIN_NAME: ats.7gram.xyz
  NODE_VERSION: '18'
  DOCKER_REPO: nuniesmith/ats
  TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}

jobs:
  # ============================================================================
  # Pre-flight Checks & Validation
  # ============================================================================
  preflight-checks:
    name: üõ´ Pre-flight Checks
    runs-on: ubuntu-latest
    outputs:
      secrets_validated: ${{ steps.validate-secrets.outputs.validated }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîê Validate Required Secrets
        id: validate-secrets
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        run: |
          echo "üîê Validating required secrets..."
          
          MISSING_SECRETS=()
          
          [[ -z "$LINODE_TOKEN" ]] && MISSING_SECRETS+=("LINODE_TOKEN")
          [[ -z "$ATS_ROOT_PASSWORD" ]] && MISSING_SECRETS+=("ATS_ROOT_PASSWORD")
          [[ -z "$TAILSCALE_AUTH_KEY" ]] && MISSING_SECRETS+=("TAILSCALE_AUTH_KEY")
          [[ -z "$JWT_SECRET" ]] && MISSING_SECRETS+=("JWT_SECRET")
          [[ -z "$DOCKER_USERNAME" ]] && MISSING_SECRETS+=("DOCKER_USERNAME")
          [[ -z "$DOCKER_TOKEN" ]] && MISSING_SECRETS+=("DOCKER_TOKEN")
          
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "‚ùå Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo "validated=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ All required secrets are configured"
            echo "validated=true" >> $GITHUB_OUTPUT
          fi
          
          # Optional secrets check
          OPTIONAL_SECRETS=()
          [[ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]] && OPTIONAL_SECRETS+=("CLOUDFLARE_API_TOKEN")
          [[ -z "${{ secrets.CLOUDFLARE_ZONE_ID }}" ]] && OPTIONAL_SECRETS+=("CLOUDFLARE_ZONE_ID")
          [[ -z "${{ secrets.DISCORD_WEBHOOK_URL }}" ]] && OPTIONAL_SECRETS+=("DISCORD_WEBHOOK_URL")
          
          if [[ ${#OPTIONAL_SECRETS[@]} -gt 0 ]]; then
            echo "‚ÑπÔ∏è Optional secrets (will disable some features):"
            printf '  - %s\n' "${OPTIONAL_SECRETS[@]}"
          fi

  # ============================================================================
  # Detect File Changes
  # ============================================================================
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    needs: preflight-checks
    if: needs.preflight-checks.outputs.secrets_validated == 'true'
    outputs:
      web-changed: ${{ steps.changes.outputs.web }}
      api-changed: ${{ steps.changes.outputs.api }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check for file changes
        id: changes
        run: |
          # Check if this is a manual trigger or first push
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - building all"
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "workflow=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"
          
          # Check for web changes
          if echo "$CHANGED_FILES" | grep -E '^src/web/|^package.*\.json$' >/dev/null 2>&1; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "üì¶ Web app changes detected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for API changes
          if echo "$CHANGED_FILES" | grep -E '^src/api/|^package.*\.json$' >/dev/null 2>&1; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "üîß API changes detected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Docker/deployment changes
          if echo "$CHANGED_FILES" | grep -E '^docker-compose|Dockerfile|\.dockerignore' >/dev/null 2>&1; then
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "üê≥ Docker changes detected"
          else
            echo "docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for workflow changes
          if echo "$CHANGED_FILES" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
            echo "workflow=true" >> $GITHUB_OUTPUT
            echo "‚öôÔ∏è Workflow changes detected"
          else
            echo "workflow=false" >> $GITHUB_OUTPUT
          fi
          
          # If any changes detected, enable docker builds
          if [[ "$(echo "$CHANGED_FILES" | grep -E '^src/|Dockerfile|docker-compose|\.github/workflows/' | wc -l)" -gt 0 ]]; then
            echo "docker=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Infrastructure Check & Setup
  # ============================================================================
  infrastructure-check:
    name: üèóÔ∏è Infrastructure Check
    runs-on: ubuntu-latest
    needs: [preflight-checks, detect-changes]
    if: needs.preflight-checks.outputs.secrets_validated == 'true'
    outputs:
      server-exists: ${{ steps.check-server.outputs.exists }}
      server-ip: ${{ steps.check-server.outputs.ip }}
      server-status: ${{ steps.check-server.outputs.status }}
      should-create: ${{ steps.decision.outputs.create }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Check Existing Linode Servers
        id: check-server
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
        run: |
          echo "üîç Checking for existing ATS servers..."
          
          # Skip if no Linode token provided
          if [[ -z "$LINODE_TOKEN" ]]; then
            echo "‚ö†Ô∏è No Linode token provided - skipping server check"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for existing servers using API
          echo "üîç Querying Linode API for existing servers..."
          SERVERS_RESPONSE=$(curl -H "Authorization: Bearer $LINODE_TOKEN" \
            "https://api.linode.com/v4/linode/instances" 2>/dev/null)
          
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Failed to query Linode API"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Look for ATS server
          SERVER_INFO=$(echo "$SERVERS_RESPONSE" | jq -r '.data[] | select(.label == "ats-server") | "\(.ipv4[0]) \(.status)"' 2>/dev/null)
          
          if [ -n "$SERVER_INFO" ]; then
            SERVER_IP=$(echo "$SERVER_INFO" | awk '{print $1}')
            SERVER_STATUS=$(echo "$SERVER_INFO" | awk '{print $2}')
            
            echo "‚úÖ Found existing ATS server:"
            echo "   Public IP: $SERVER_IP"
            echo "   Status: $SERVER_STATUS"
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "status=$SERVER_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No existing ATS server found"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
          fi

      - name: ü§î Deployment Decision
        id: decision
        run: |
          echo "ü§î Making deployment decisions..."
          
          SERVER_EXISTS="${{ steps.check-server.outputs.exists }}"
          CREATE_NEW="${{ env.CREATE_NEW_SERVER }}"
          DEPLOYMENT_MODE="${{ env.DEPLOYMENT_MODE }}"
          
          echo "Server exists: $SERVER_EXISTS"
          echo "Create new requested: $CREATE_NEW"
          echo "Deployment mode: $DEPLOYMENT_MODE"
          
          if [[ "$SERVER_EXISTS" == "true" ]]; then
            echo "‚úÖ Server exists - will use existing server"
            echo "create=false" >> $GITHUB_OUTPUT
          elif [[ "$CREATE_NEW" == "true" ]]; then
            echo "üî® Will create new server"
            echo "create=true" >> $GITHUB_OUTPUT
          elif [[ "$DEPLOYMENT_MODE" == "docker-only" || "$DEPLOYMENT_MODE" == "full-deploy" || "$DEPLOYMENT_MODE" == "web-only" ]]; then
            echo "üî® Deployment requested but no server exists - will create one"
            echo "create=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No server exists and create_new_server=false"
            echo "create=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Create New Server (if needed)
  # ============================================================================
  create-server:
    name: üî® Create ATS Server
    runs-on: ubuntu-latest
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.should-create == 'true'
    outputs:
      server-ip: ${{ steps.create.outputs.ip }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üî® Create Linode Server
        id: create
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üî® Creating new ATS server..."
          
          # Install Linode CLI
          pip3 install linode-cli
          
          # Configure Linode CLI non-interactively
          mkdir -p ~/.config/linode-cli
          cat > ~/.config/linode-cli/config << EOF
          [DEFAULT]
          token = $LINODE_TOKEN
          region = ${{ env.TARGET_REGION }}
          type = ${{ env.SERVER_TYPE }}
          image = linode/arch
          authorized_users = 
          EOF
          
          # Set LINODE_CLI_TOKEN environment variable to avoid interactive prompts
          export LINODE_CLI_TOKEN="$LINODE_TOKEN"
          
          # Create the server using API directly to avoid CLI configuration issues
          echo "üî® Creating server via Linode API..."
          RESULT=$(curl -H "Authorization: Bearer $LINODE_TOKEN" \
            -H "Content-Type: application/json" \
            -X POST "https://api.linode.com/v4/linode/instances" \
            -d "{
              \"label\": \"ats-server\",
              \"region\": \"${{ env.TARGET_REGION }}\",
              \"type\": \"${{ env.SERVER_TYPE }}\",
              \"image\": \"linode/arch\",
              \"root_pass\": \"$ATS_ROOT_PASSWORD\",
              \"booted\": true
            }")
          
          echo "API Response: $RESULT"
          
          # Extract server IP
          SERVER_IP=$(echo "$RESULT" | jq -r '.ipv4[0]')
          if [[ "$SERVER_IP" == "null" || -z "$SERVER_IP" ]]; then
            echo "‚ùå Failed to create server or extract IP"
            echo "API Response: $RESULT"
            exit 1
          fi
          
          echo "‚úÖ Server created with IP: $SERVER_IP"
          echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
          
          # Wait for server to boot
          echo "‚è≥ Waiting for server to boot..."
          sleep 120

      - name: üîß Stage 1 - Initial Server Setup
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          echo "üîß Stage 1: Initial Arch Linux setup..."
          
          # Wait for SSH to be available
          for i in {1..10}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "echo 'Server ready'"; then
              echo "‚úÖ SSH connection established"
              break
            fi
            echo "‚è≥ Waiting for SSH... (attempt $i/10)"
            sleep 30
          done
          
          # Stage 1: System setup and stage 2 service creation
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "üîß Stage 1: System initialization..."
            
            # Update system
            pacman -Syu --noconfirm
            
            # Install essential packages
            pacman -S --noconfirm curl wget git unzip nginx docker docker-compose tailscale netdata
            
            # Verify docker-compose installation
            if ! command -v docker-compose >/dev/null 2>&1; then
              echo "Installing docker-compose via pip as fallback..."
              pacman -S --noconfirm python-pip
              pip install docker-compose
            fi
            
            # Enable essential services
            systemctl enable docker
            systemctl enable tailscaled
            systemctl enable netdata
            
            # Create stage 2 deployment script
            cat > /opt/ats-stage2-deploy.sh << 'STAGE2EOF'
          #!/bin/bash
          echo "üöÄ Stage 2: Post-reboot deployment with Tailscale..."
          
          # Start Tailscale and authenticate
          systemctl start tailscaled
          sleep 5
          
          # Authenticate with Tailscale (using authkey from environment)
          if [ -n "$TAILSCALE_AUTH_KEY" ]; then
            tailscale up --authkey="$TAILSCALE_AUTH_KEY" --accept-routes --hostname=ats
            echo "‚úÖ Tailscale authentication completed with hostname 'ats'"
          else
            echo "‚ö†Ô∏è No Tailscale authkey provided, skipping Tailscale setup"
          fi
          
          # Set hostname to match domain
          hostnamectl set-hostname ats
          echo "127.0.0.1 ats ats.7gram.xyz" >> /etc/hosts
          echo "‚úÖ Hostname set to 'ats'"
          
          # Start Docker
          systemctl start docker
          systemctl enable docker
          
          # Wait for Docker to be ready
          for i in {1..20}; do
            if docker info >/dev/null 2>&1; then
              echo "‚úÖ Docker daemon is ready"
              break
            fi
            echo "‚è≥ Waiting for Docker daemon... (attempt $i/20)"
            sleep 3
          done
          
          # Verify docker-compose is available
          if ! command -v docker-compose >/dev/null 2>&1; then
            echo "Installing docker-compose..."
            pacman -S --noconfirm docker-compose || pip install docker-compose
          fi
          echo "‚úÖ Docker and docker-compose ready"
          
          # Start and configure Netdata
          systemctl start netdata
          echo "‚úÖ Netdata monitoring started on port 19999"
          
          # Configure firewall for Arch Linux
          if command -v ufw >/dev/null 2>&1; then
            ufw allow ssh
            ufw allow http
            ufw allow https
            ufw allow 19999
            ufw --force enable
          else
            # Configure iptables for Arch
            iptables -A INPUT -i lo -j ACCEPT
            iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
            iptables -A INPUT -p tcp --dport 22 -j ACCEPT
            iptables -A INPUT -p tcp --dport 80 -j ACCEPT
            iptables -A INPUT -p tcp --dport 443 -j ACCEPT
            iptables -A INPUT -p tcp --dport 3001 -j ACCEPT
            iptables -A INPUT -p tcp --dport 19999 -j ACCEPT
            iptables -A INPUT -j DROP
            
            # Save iptables rules
            mkdir -p /etc/iptables
            iptables-save > /etc/iptables/iptables.rules
            systemctl enable iptables
          fi
          
          # Create deployment directory
          mkdir -p /opt/ats
          
          echo "‚úÖ Stage 2 setup completed - ready for deployment"
          
          # Signal completion
          touch /opt/stage2-complete
          STAGE2EOF
            
            chmod +x /opt/ats-stage2-deploy.sh
            
            # Create systemd service for stage 2
            cat > /etc/systemd/system/ats-stage2.service << 'SERVICEEOF'
          [Unit]
          Description=ATS Stage 2 Deployment
          After=network.target
          Wants=network.target
          
          [Service]
          Type=oneshot
          Environment=TAILSCALE_AUTH_KEY=$TAILSCALE_AUTH_KEY
          ExecStart=/opt/ats-stage2-deploy.sh
          RemainAfterExit=yes
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          SERVICEEOF
            
            # Enable stage 2 service
            systemctl enable ats-stage2.service
            
            echo "‚úÖ Stage 1 complete - systemd service created for stage 2"
            echo "üîÑ Preparing for reboot..."
          EOF
          
          # Set Tailscale authkey in the service environment
          if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
              "sed -i 's/\$TAILSCALE_AUTH_KEY/$TAILSCALE_AUTH_KEY/' /etc/systemd/system/ats-stage2.service"
          fi
          
          # Reload systemd and reboot
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
            "systemctl daemon-reload && reboot" || true
          
          echo "üîÑ Server rebooting for stage 2..."

      - name: ‚è≥ Wait for Stage 2 Completion
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "‚è≥ Waiting for server reboot and stage 2 completion..."
          
          # Wait for reboot
          sleep 60
          
          # Wait for SSH to come back up and stage 2 to complete
          for i in {1..20}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "test -f /opt/stage2-complete"; then
              echo "‚úÖ Stage 2 deployment completed successfully"
              break
            fi
            echo "‚è≥ Waiting for stage 2 completion... (attempt $i/20)"
            sleep 30
          done
          
          # Verify services are running
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "üîç Verifying services..."
            systemctl status docker --no-pager
            systemctl status tailscaled --no-pager
            systemctl status netdata --no-pager
            
            # Check Tailscale status
            tailscale status || echo "‚ö†Ô∏è Tailscale not connected"
            
            echo "‚úÖ Two-stage deployment completed"
            echo "üìä Netdata monitoring available at: http://$(hostname -I | awk '{print $1}'):19999"
          EOF

  # ============================================================================
  # Build and Push Docker Images to DockerHub
  # ============================================================================
  build-docker-images:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
       (needs.detect-changes.outputs.docker-changed == 'true' || 
        needs.detect-changes.outputs.web-changed == 'true' || 
        needs.detect-changes.outputs.api-changed == 'true' ||
        github.event_name == 'workflow_dispatch'))
    outputs:
      web-image: ${{ steps.meta.outputs.web-image }}
      api-image: ${{ steps.meta.outputs.api-image }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üè∑Ô∏è Generate image tags
        id: meta
        run: |
          # Generate version tag
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="latest"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="pr-${{ github.event.number }}"
          fi
          
          WEB_IMAGE="${{ env.DOCKER_REPO }}:web-${VERSION}"
          API_IMAGE="${{ env.DOCKER_REPO }}:api-${VERSION}"
          
          echo "web-image=${WEB_IMAGE}" >> $GITHUB_OUTPUT
          echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Will build:"
          echo "  Web: ${WEB_IMAGE}"
          echo "  API: ${API_IMAGE}"

      - name: üèóÔ∏è Build and Push React Web App
        if: needs.detect-changes.outputs.web-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/web
          file: ./src/web/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.web-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_API_URL=http://localhost/api
            VITE_SOCKET_URL=http://localhost

      - name: üèóÔ∏è Build and Push API Server
        if: needs.detect-changes.outputs.api-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/api
          file: ./src/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.api-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy-to-server:
    name: üöÄ Deploy to ATS Server
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, create-server, detect-changes]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
      (needs.build-docker-images.result == 'success' || needs.build-docker-images.result == 'skipped')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üéØ Determine Target Server
        id: target
        run: |
          if [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
            echo "Using existing server: $SERVER_IP"
          elif [[ "${{ needs.create-server.result }}" == "success" ]]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
            echo "Using new server: $SERVER_IP"
          else
            echo "‚ùå No server available for deployment"
            exit 1
          fi
          echo "server-ip=$SERVER_IP" >> $GITHUB_OUTPUT

      - name: üì¶ Deploy Docker Stack
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          WEB_IMAGE: ${{ needs.build-docker-images.outputs.web-image }}
          API_IMAGE: ${{ needs.build-docker-images.outputs.api-image }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üöÄ Deploying to server: $SERVER_IP"
          echo "üê≥ Using images:"
          echo "   Web: ${WEB_IMAGE:-nuniesmith/ats:web-latest}"
          echo "   API: ${API_IMAGE:-nuniesmith/ats:api-latest}"
          
          # Create deployment directory and subdirectories
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "mkdir -p /opt/ats/config"
          
          # Copy deployment files
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@$SERVER_IP:/opt/ats/docker-compose.yml
          
          # Copy nginx configuration
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/nginx.conf root@$SERVER_IP:/opt/ats/config/nginx.conf
          
          # Create environment file
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "cat > /opt/ats/.env << 'EOF'
          NODE_ENV=production
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ env.DOMAIN_NAME }}
          ATS_DEFAULT_PASSWORD=${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID=3530633316
          WEB_IMAGE=${WEB_IMAGE:-nuniesmith/ats:web-latest}
          API_IMAGE=${API_IMAGE:-nuniesmith/ats:api-latest}
          CLOUDFLARE_API_TOKEN=${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID=${{ secrets.CLOUDFLARE_ZONE_ID }}
          DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }}
          EOF"
          
          # Deploy the stack
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /opt/ats
            
            # Ensure Docker daemon is running
            echo 'Starting Docker daemon...'
            systemctl start docker
            systemctl enable docker
            
            # Wait for Docker daemon to be ready
            for i in {1..30}; do
              if docker info >/dev/null 2>&1; then
                echo 'Docker daemon is ready'
                break
              fi
              echo \"Waiting for Docker daemon... (attempt \$i/30)\"
              sleep 3
            done
            
            # Check if docker-compose is available, install if not
            if ! command -v docker-compose >/dev/null 2>&1; then
              echo 'Installing docker-compose...'
              pacman -S --noconfirm docker-compose || pip install docker-compose
            fi
            
            # Verify Docker is working
            docker version
            docker-compose version
            
            # Pull and start containers
            echo 'Pulling Docker images...'
            docker-compose pull
            
            echo 'Starting containers...'
            docker-compose up -d
            
            # Show container status
            docker-compose ps
            docker-compose logs --tail=20
            
            # Wait for health checks
            echo 'Waiting for services to be healthy...'
            for i in {1..30}; do
              if curl -f http://localhost/health >/dev/null 2>&1; then
                echo 'Web app is healthy'
                break
              fi
              echo \"Waiting for web app... (attempt \$i/30)\"
              sleep 10
            done
            
            for i in {1..30}; do
              if curl -f http://localhost:3001/health >/dev/null 2>&1; then
                echo 'API server is healthy'
                break
              fi
              echo \"Waiting for API server... (attempt \$i/30)\"
              sleep 10
            done
          "

      - name: üîó Verify Tailscale Connection
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üîó Verifying Tailscale connection..."
          
          # Check Tailscale status and get internal IP
          TAILSCALE_STATUS=$(sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "tailscale status --json 2>/dev/null || echo '{}'")
          
          if echo "$TAILSCALE_STATUS" | jq -e '.Self.Online' >/dev/null 2>&1; then
            TAILSCALE_IP=$(echo "$TAILSCALE_STATUS" | jq -r '.Self.TailscaleIPs[0] // "unknown"')
            echo "‚úÖ Tailscale connected successfully"
            echo "   Public IP: $SERVER_IP"
            echo "   Tailscale IP: $TAILSCALE_IP"
            echo "   Hostname: ats"
            echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Tailscale not connected or authentication failed"
            echo "Attempting manual Tailscale authentication..."
            
            # Retry Tailscale authentication if failed
            if [[ -n "${{ secrets.TAILSCALE_AUTH_KEY }}" ]]; then
              sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
                systemctl restart tailscaled
                sleep 10
                tailscale up --authkey='${{ secrets.TAILSCALE_AUTH_KEY }}' --accept-routes --hostname=ats --force-reauth
                sleep 5
                tailscale status
              "
            fi
          fi

      - name: üåê Update Cloudflare DNS Records
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          DOMAIN_NAME: ${{ env.DOMAIN_NAME }}
        run: |
          if [[ -n "$CLOUDFLARE_API_TOKEN" && -n "$CLOUDFLARE_ZONE_ID" && -n "$DOMAIN_NAME" ]]; then
            echo "üåê Updating Cloudflare DNS records for $DOMAIN_NAME..."
            
            # Function to update DNS record
            update_dns_record() {
              local record_name="$1"
              local record_ip="$2"
              local record_type="${3:-A}"
              
              echo "üîÑ Updating $record_type record: $record_name -> $record_ip"
              
              # Get existing record ID
              RECORD_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$record_name&type=$record_type" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json")
              
              RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id // "null"')
              
              if [[ "$RECORD_ID" != "null" && "$RECORD_ID" != "" ]]; then
                # Update existing record
                UPDATE_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
                  -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                  -H "Content-Type: application/json" \
                  --data "{\"type\":\"$record_type\",\"name\":\"$record_name\",\"content\":\"$record_ip\",\"ttl\":1}")
                
                if echo "$UPDATE_RESPONSE" | jq -e '.success' >/dev/null; then
                  echo "‚úÖ Updated $record_name ($record_type) -> $record_ip"
                else
                  echo "‚ùå Failed to update $record_name: $(echo "$UPDATE_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')"
                fi
              else
                # Create new record
                CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
                  -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                  -H "Content-Type: application/json" \
                  --data "{\"type\":\"$record_type\",\"name\":\"$record_name\",\"content\":\"$record_ip\",\"ttl\":1}")
                
                if echo "$CREATE_RESPONSE" | jq -e '.success' >/dev/null; then
                  echo "‚úÖ Created $record_name ($record_type) -> $record_ip"
                else
                  echo "‚ùå Failed to create $record_name: $(echo "$CREATE_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')"
                fi
              fi
            }
            
            # Update main domain A record
            update_dns_record "$DOMAIN_NAME" "$SERVER_IP" "A"
            
            # Update www subdomain
            update_dns_record "www.$DOMAIN_NAME" "$SERVER_IP" "A"
            
            # Update API subdomain if needed
            update_dns_record "api.$DOMAIN_NAME" "$SERVER_IP" "A"
            
            echo "üåê DNS update completed"
            echo "   Main domain: https://$DOMAIN_NAME"
            echo "   WWW: https://www.$DOMAIN_NAME"
            echo "   API: https://api.$DOMAIN_NAME"
            
            # Wait for DNS propagation
            echo "‚è≥ Waiting 30 seconds for DNS propagation..."
            sleep 30
            
          else
            echo "‚ÑπÔ∏è Cloudflare credentials not configured, skipping DNS update"
            echo "  CLOUDFLARE_API_TOKEN: $([[ -n "$CLOUDFLARE_API_TOKEN" ]] && echo "‚úÖ Set" || echo "‚ùå Missing")"
            echo "  CLOUDFLARE_ZONE_ID: $([[ -n "$CLOUDFLARE_ZONE_ID" ]] && echo "‚úÖ Set" || echo "‚ùå Missing")"
            echo "  DOMAIN_NAME: $([[ -n "$DOMAIN_NAME" ]] && echo "‚úÖ Set ($DOMAIN_NAME)" || echo "‚ùå Missing")"
          fi

  # ============================================================================
  # Deployment Summary & Notifications
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, deploy-to-server, create-server, detect-changes]
    if: always()
    steps:
      - name: üìã Generate Summary
        run: |
          echo "# üöÄ ATS Server Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Server status
          if [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "‚úÖ **New Server Created**: ${{ needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            echo "‚úÖ **Using Existing Server**: ${{ needs.infrastructure-check.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.create-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Server Creation Skipped**: No server exists and create_new_server=false" >> $GITHUB_STEP_SUMMARY
            echo "   - To deploy, set create_new_server=true in workflow inputs" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.result }}" == "failure" ]]; then
            echo "‚ùå **Infrastructure Check Failed**: Could not check for existing servers" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Build status
          if [[ "${{ needs.build-docker-images.result }}" == "success" ]]; then
            echo "‚úÖ **Docker Images Built and Pushed**" >> $GITHUB_STEP_SUMMARY
            echo "   - Web: ${{ needs.build-docker-images.outputs.web-image }}" >> $GITHUB_STEP_SUMMARY
            echo "   - API: ${{ needs.build-docker-images.outputs.api-image }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.build-docker-images.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Docker Build Skipped**: No code changes detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Deployment status
          if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
            echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê Access Points" >> $GITHUB_STEP_SUMMARY
            echo "- **Web Interface**: http://${{ env.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
            echo "- **API Server**: http://${{ env.DOMAIN_NAME }}:3001" >> $GITHUB_STEP_SUMMARY
            echo "- **Netdata Monitoring**: http://${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}:19999" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üîó Network Information" >> $GITHUB_STEP_SUMMARY
            echo "- **Public IP**: ${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Hostname**: ats" >> $GITHUB_STEP_SUMMARY
            echo "- **Tailscale**: Connected with hostname 'ats'" >> $GITHUB_STEP_SUMMARY
            echo "- **DNS**: Updated for ${{ env.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-to-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Deployment Skipped**: No server available" >> $GITHUB_STEP_SUMMARY
            echo "   - Create a server first by setting create_new_server=true" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì¢ Discord Notification
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          SERVER_IP: ${{ needs.infrastructure-check.outputs.server-ip || needs.create-server.outputs.server-ip }}
        run: |
          if [[ -n "$DISCORD_WEBHOOK_URL" ]]; then
            echo "üì¢ Sending Discord notification..."
            
            # Determine overall status
            if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
              STATUS="‚úÖ Success"
              COLOR=3066993  # Green
              DESCRIPTION="ATS Server deployment completed successfully!"
            elif [[ "${{ needs.create-server.result }}" == "success" && "${{ needs.deploy-to-server.result }}" != "success" ]]; then
              STATUS="‚ö†Ô∏è Partial Success"
              COLOR=16776960  # Yellow
              DESCRIPTION="Server created but deployment had issues"
            else
              STATUS="‚ùå Failed"
              COLOR=15158332  # Red
              DESCRIPTION="Deployment failed - check logs for details"
            fi
            
            # Create Discord embed
            EMBED_DATA=$(cat <<EOF
          {
            "embeds": [{
              "title": "üöÄ ATS Server Deployment",
              "description": "$DESCRIPTION",
              "color": $COLOR,
              "fields": [
                {
                  "name": "üéØ Status",
                  "value": "$STATUS",
                  "inline": true
                },
                {
                  "name": "üåê Domain",
                  "value": "${{ env.DOMAIN_NAME }}",
                  "inline": true
                },
                {
                  "name": "üìç Server IP",
                  "value": "$SERVER_IP",
                  "inline": true
                },
                {
                  "name": "üîó Access Points",
                  "value": "‚Ä¢ [Web App](http://${{ env.DOMAIN_NAME }})\n‚Ä¢ [API](http://${{ env.DOMAIN_NAME }}:3001)\n‚Ä¢ [Monitoring](http://$SERVER_IP:19999)",
                  "inline": false
                },
                {
                  "name": "üìä Deployment Info",
                  "value": "‚Ä¢ Commit: \`${{ github.sha }}\`\n‚Ä¢ Branch: \`${{ github.ref_name }}\`\n‚Ä¢ Triggered by: ${{ github.event_name }}",
                  "inline": false
                }
              ],
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "footer": {
                "text": "ATS Deployment Pipeline"
              }
            }]
          }
          EOF
            )
            
            # Send to Discord
            curl -H "Content-Type: application/json" \
              -d "$EMBED_DATA" \
              "$DISCORD_WEBHOOK_URL"
            
            echo "‚úÖ Discord notification sent"
          else
            echo "‚ÑπÔ∏è Discord webhook not configured, skipping notification"
          fi
