name: üöÄ ATS Server Complete Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'What to deploy'
        required: true
        type: choice
        options:
          - 'full-deploy'          # Deploy both React web app and ATS server
          - 'web-only'             # Deploy only React web interface
          - 'docker-only'          # Deploy only Docker containers
          - 'ats-server-only'      # Deploy only ATS dedicated server
          - 'update-server'        # Update existing deployment
        default: 'docker-only'
      
      create_new_server:
        description: 'Create new Linode server for ATS'
        required: false
        type: boolean
        default: true
      
      server_type:
        description: 'Server type to create'
        required: false
        type: choice
        options:
          - 'g6-standard-1'        # 2GB RAM, 1 CPU (recommended for ATS)
          - 'g6-standard-2'        # 4GB RAM, 1 CPU 
          - 'g6-standard-4'        # 8GB RAM, 2 CPU (for multiple servers)
          - 'g6-standard-8'        # 16GB RAM, 4 CPU (for heavy mod loads)
        default: 'g6-standard-1'
      
      target_region:
        description: 'Linode region for server'
        required: false
        type: choice
        options:
          - 'us-east'              # New York/Newark
          - 'us-central'           # Dallas
          - 'us-west'              # Los Angeles
          - 'ca-central'           # Toronto
          - 'eu-west'              # London
        default: 'ca-central'

env:
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'docker-only' }}
  CREATE_NEW_SERVER: ${{ github.event.inputs.create_new_server || 'true' }}
  SERVER_TYPE: ${{ github.event.inputs.server_type || 'g6-standard-1' }}
  TARGET_REGION: ${{ github.event.inputs.target_region || 'ca-central' }}
  DOMAIN_NAME: ats.7gram.xyz
  NODE_VERSION: '18'
  DOCKER_REPO: nuniesmith/ats
  TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}

jobs:
  # ============================================================================
  # Detect File Changes
  # ============================================================================
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      web-changed: ${{ steps.changes.outputs.web }}
      api-changed: ${{ steps.changes.outputs.api }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check for file changes
        id: changes
        run: |
          # Check if this is a manual trigger or first push
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - building all"
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "workflow=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"
          
          # Check for web changes
          if echo "$CHANGED_FILES" | grep -E '^src/web/|^package.*\.json$' >/dev/null 2>&1; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "üì¶ Web app changes detected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for API changes
          if echo "$CHANGED_FILES" | grep -E '^src/api/|^package.*\.json$' >/dev/null 2>&1; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "üîß API changes detected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Docker/deployment changes
          if echo "$CHANGED_FILES" | grep -E '^docker-compose|Dockerfile|\.dockerignore' >/dev/null 2>&1; then
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "üê≥ Docker changes detected"
          else
            echo "docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for workflow changes
          if echo "$CHANGED_FILES" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
            echo "workflow=true" >> $GITHUB_OUTPUT
            echo "‚öôÔ∏è Workflow changes detected"
          else
            echo "workflow=false" >> $GITHUB_OUTPUT
          fi
          
          # If any changes detected, enable docker builds
          if [[ "$(echo "$CHANGED_FILES" | grep -E '^src/|Dockerfile|docker-compose|\.github/workflows/' | wc -l)" -gt 0 ]]; then
            echo "docker=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Infrastructure Check & Setup
  # ============================================================================
  infrastructure-check:
    name: üèóÔ∏è Infrastructure Check
    runs-on: ubuntu-latest
    needs: detect-changes
    outputs:
      server-exists: ${{ steps.check-server.outputs.exists }}
      server-ip: ${{ steps.check-server.outputs.ip }}
      server-status: ${{ steps.check-server.outputs.status }}
      should-create: ${{ steps.decision.outputs.create }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Check Existing Linode Servers
        id: check-server
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
        run: |
          echo "üîç Checking for existing ATS servers..."
          
          # Skip if no Linode token provided
          if [[ -z "$LINODE_TOKEN" ]]; then
            echo "‚ö†Ô∏è No Linode token provided - skipping server check"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for existing servers using API
          echo "üîç Querying Linode API for existing servers..."
          SERVERS_RESPONSE=$(curl -H "Authorization: Bearer $LINODE_TOKEN" \
            "https://api.linode.com/v4/linode/instances" 2>/dev/null)
          
          if [[ $? -ne 0 ]]; then
            echo "‚ùå Failed to query Linode API"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Look for ATS server
          SERVER_INFO=$(echo "$SERVERS_RESPONSE" | jq -r '.data[] | select(.label == "ats-server") | "\(.ipv4[0]) \(.status)"' 2>/dev/null)
          
          if [ -n "$SERVER_INFO" ]; then
            SERVER_IP=$(echo "$SERVER_INFO" | awk '{print $1}')
            SERVER_STATUS=$(echo "$SERVER_INFO" | awk '{print $2}')
            
            echo "‚úÖ Found existing ATS server:"
            echo "   Public IP: $SERVER_IP"
            echo "   Status: $SERVER_STATUS"
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "status=$SERVER_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No existing ATS server found"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
          fi

      - name: ü§î Deployment Decision
        id: decision
        run: |
          echo "ü§î Making deployment decisions..."
          
          SERVER_EXISTS="${{ steps.check-server.outputs.exists }}"
          CREATE_NEW="${{ env.CREATE_NEW_SERVER }}"
          DEPLOYMENT_MODE="${{ env.DEPLOYMENT_MODE }}"
          
          echo "Server exists: $SERVER_EXISTS"
          echo "Create new requested: $CREATE_NEW"
          echo "Deployment mode: $DEPLOYMENT_MODE"
          
          if [[ "$SERVER_EXISTS" == "true" ]]; then
            echo "‚úÖ Server exists - will use existing server"
            echo "create=false" >> $GITHUB_OUTPUT
          elif [[ "$CREATE_NEW" == "true" ]]; then
            echo "üî® Will create new server"
            echo "create=true" >> $GITHUB_OUTPUT
          elif [[ "$DEPLOYMENT_MODE" == "docker-only" || "$DEPLOYMENT_MODE" == "full-deploy" || "$DEPLOYMENT_MODE" == "web-only" ]]; then
            echo "üî® Deployment requested but no server exists - will create one"
            echo "create=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No server exists and create_new_server=false"
            echo "create=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Create New Server (if needed)
  # ============================================================================
  create-server:
    name: üî® Create ATS Server
    runs-on: ubuntu-latest
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.should-create == 'true'
    outputs:
      server-ip: ${{ steps.create.outputs.ip }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üî® Create Linode Server
        id: create
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üî® Creating new ATS server..."
          
          # Install Linode CLI
          pip3 install linode-cli
          
          # Configure Linode CLI non-interactively
          mkdir -p ~/.config/linode-cli
          cat > ~/.config/linode-cli/config << EOF
          [DEFAULT]
          token = $LINODE_TOKEN
          region = ${{ env.TARGET_REGION }}
          type = ${{ env.SERVER_TYPE }}
          image = linode/arch
          authorized_users = 
          EOF
          
          # Set LINODE_CLI_TOKEN environment variable to avoid interactive prompts
          export LINODE_CLI_TOKEN="$LINODE_TOKEN"
          
          # Create the server using API directly to avoid CLI configuration issues
          echo "üî® Creating server via Linode API..."
          RESULT=$(curl -H "Authorization: Bearer $LINODE_TOKEN" \
            -H "Content-Type: application/json" \
            -X POST "https://api.linode.com/v4/linode/instances" \
            -d "{
              \"label\": \"ats-server\",
              \"region\": \"${{ env.TARGET_REGION }}\",
              \"type\": \"${{ env.SERVER_TYPE }}\",
              \"image\": \"linode/arch\",
              \"root_pass\": \"$ATS_ROOT_PASSWORD\",
              \"booted\": true
            }")
          
          echo "API Response: $RESULT"
          
          # Extract server IP
          SERVER_IP=$(echo "$RESULT" | jq -r '.ipv4[0]')
          if [[ "$SERVER_IP" == "null" || -z "$SERVER_IP" ]]; then
            echo "‚ùå Failed to create server or extract IP"
            echo "API Response: $RESULT"
            exit 1
          fi
          
          echo "‚úÖ Server created with IP: $SERVER_IP"
          echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
          
          # Wait for server to boot
          echo "‚è≥ Waiting for server to boot..."
          sleep 120

      - name: üîß Stage 1 - Initial Server Setup
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          echo "üîß Stage 1: Initial Arch Linux setup..."
          
          # Wait for SSH to be available
          for i in {1..10}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "echo 'Server ready'"; then
              echo "‚úÖ SSH connection established"
              break
            fi
            echo "‚è≥ Waiting for SSH... (attempt $i/10)"
            sleep 30
          done
          
          # Stage 1: System setup and stage 2 service creation
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "üîß Stage 1: System initialization..."
            
            # Update system
            pacman -Syu --noconfirm
            
            # Install essential packages
            pacman -S --noconfirm curl wget git unzip nginx docker docker-compose tailscale
            
            # Enable essential services
            systemctl enable docker
            systemctl enable tailscaled
            
            # Create stage 2 deployment script
            cat > /opt/ats-stage2-deploy.sh << 'STAGE2EOF'
          #!/bin/bash
          echo "üöÄ Stage 2: Post-reboot deployment with Tailscale..."
          
          # Start Tailscale and authenticate
          systemctl start tailscaled
          sleep 5
          
          # Authenticate with Tailscale (using authkey from environment)
          if [ -n "$TAILSCALE_AUTH_KEY" ]; then
            tailscale up --authkey="$TAILSCALE_AUTH_KEY" --accept-routes
            echo "‚úÖ Tailscale authentication completed"
          else
            echo "‚ö†Ô∏è No Tailscale authkey provided, skipping Tailscale setup"
          fi
          
          # Start Docker
          systemctl start docker
          
          # Configure firewall for Arch Linux
          if command -v ufw >/dev/null 2>&1; then
            ufw allow ssh
            ufw allow http
            ufw allow https
            ufw --force enable
          else
            # Configure iptables for Arch
            iptables -A INPUT -i lo -j ACCEPT
            iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
            iptables -A INPUT -p tcp --dport 22 -j ACCEPT
            iptables -A INPUT -p tcp --dport 80 -j ACCEPT
            iptables -A INPUT -p tcp --dport 443 -j ACCEPT
            iptables -A INPUT -p tcp --dport 3001 -j ACCEPT
            iptables -A INPUT -j DROP
            
            # Save iptables rules
            mkdir -p /etc/iptables
            iptables-save > /etc/iptables/iptables.rules
            systemctl enable iptables
          fi
          
          # Create deployment directory
          mkdir -p /opt/ats
          
          echo "‚úÖ Stage 2 setup completed - ready for deployment"
          
          # Signal completion
          touch /opt/stage2-complete
          STAGE2EOF
            
            chmod +x /opt/ats-stage2-deploy.sh
            
            # Create systemd service for stage 2
            cat > /etc/systemd/system/ats-stage2.service << 'SERVICEEOF'
          [Unit]
          Description=ATS Stage 2 Deployment
          After=network.target
          Wants=network.target
          
          [Service]
          Type=oneshot
          Environment=TAILSCALE_AUTH_KEY=$TAILSCALE_AUTH_KEY
          ExecStart=/opt/ats-stage2-deploy.sh
          RemainAfterExit=yes
          StandardOutput=journal
          StandardError=journal
          
          [Install]
          WantedBy=multi-user.target
          SERVICEEOF
            
            # Enable stage 2 service
            systemctl enable ats-stage2.service
            
            echo "‚úÖ Stage 1 complete - systemd service created for stage 2"
            echo "üîÑ Preparing for reboot..."
          EOF
          
          # Set Tailscale authkey in the service environment
          if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
              "sed -i 's/\$TAILSCALE_AUTH_KEY/$TAILSCALE_AUTH_KEY/' /etc/systemd/system/ats-stage2.service"
          fi
          
          # Reload systemd and reboot
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP \
            "systemctl daemon-reload && reboot" || true
          
          echo "üîÑ Server rebooting for stage 2..."

      - name: ‚è≥ Wait for Stage 2 Completion
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "‚è≥ Waiting for server reboot and stage 2 completion..."
          
          # Wait for reboot
          sleep 60
          
          # Wait for SSH to come back up and stage 2 to complete
          for i in {1..20}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "test -f /opt/stage2-complete"; then
              echo "‚úÖ Stage 2 deployment completed successfully"
              break
            fi
            echo "‚è≥ Waiting for stage 2 completion... (attempt $i/20)"
            sleep 30
          done
          
          # Verify services are running
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "üîç Verifying services..."
            systemctl status docker --no-pager
            systemctl status tailscaled --no-pager
            
            # Check Tailscale status
            tailscale status || echo "‚ö†Ô∏è Tailscale not connected"
            
            echo "‚úÖ Two-stage deployment completed"
          EOF

  # ============================================================================
  # Build and Push Docker Images to DockerHub
  # ============================================================================
  build-docker-images:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
       (needs.detect-changes.outputs.docker-changed == 'true' || 
        needs.detect-changes.outputs.web-changed == 'true' || 
        needs.detect-changes.outputs.api-changed == 'true' ||
        github.event_name == 'workflow_dispatch'))
    outputs:
      web-image: ${{ steps.meta.outputs.web-image }}
      api-image: ${{ steps.meta.outputs.api-image }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üè∑Ô∏è Generate image tags
        id: meta
        run: |
          # Generate version tag
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="latest"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="pr-${{ github.event.number }}"
          fi
          
          WEB_IMAGE="${{ env.DOCKER_REPO }}:web-${VERSION}"
          API_IMAGE="${{ env.DOCKER_REPO }}:api-${VERSION}"
          
          echo "web-image=${WEB_IMAGE}" >> $GITHUB_OUTPUT
          echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Will build:"
          echo "  Web: ${WEB_IMAGE}"
          echo "  API: ${API_IMAGE}"

      - name: üèóÔ∏è Build and Push React Web App
        if: needs.detect-changes.outputs.web-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/web
          file: ./src/web/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.web-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_API_URL=http://localhost/api
            VITE_SOCKET_URL=http://localhost

      - name: üèóÔ∏è Build and Push API Server
        if: needs.detect-changes.outputs.api-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/api
          file: ./src/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.api-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy-to-server:
    name: üöÄ Deploy to ATS Server
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, create-server, detect-changes]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
      (needs.build-docker-images.result == 'success' || needs.build-docker-images.result == 'skipped')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üéØ Determine Target Server
        id: target
        run: |
          if [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
            echo "Using existing server: $SERVER_IP"
          elif [[ "${{ needs.create-server.result }}" == "success" ]]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
            echo "Using new server: $SERVER_IP"
          else
            echo "‚ùå No server available for deployment"
            exit 1
          fi
          echo "server-ip=$SERVER_IP" >> $GITHUB_OUTPUT

      - name: üì¶ Deploy Docker Stack
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          WEB_IMAGE: ${{ needs.build-docker-images.outputs.web-image }}
          API_IMAGE: ${{ needs.build-docker-images.outputs.api-image }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üöÄ Deploying to server: $SERVER_IP"
          echo "üê≥ Using images:"
          echo "   Web: ${WEB_IMAGE:-nuniesmith/ats:web-latest}"
          echo "   API: ${API_IMAGE:-nuniesmith/ats:api-latest}"
          
          # Create deployment directory and subdirectories
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "mkdir -p /opt/ats/config"
          
          # Copy deployment files
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@$SERVER_IP:/opt/ats/docker-compose.yml
          
          # Copy nginx configuration
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no config/nginx.conf root@$SERVER_IP:/opt/ats/config/nginx.conf
          
          # Create environment file
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "cat > /opt/ats/.env << 'EOF'
          NODE_ENV=production
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ env.DOMAIN_NAME }}
          ATS_DEFAULT_PASSWORD=${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID=3530633316
          WEB_IMAGE=${WEB_IMAGE:-nuniesmith/ats:web-latest}
          API_IMAGE=${API_IMAGE:-nuniesmith/ats:api-latest}
          CLOUDFLARE_API_TOKEN=${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID=${{ secrets.CLOUDFLARE_ZONE_ID }}
          DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }}
          EOF"
          
          # Deploy the stack
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /opt/ats
            docker-compose pull
            docker-compose up -d
            
            # Wait for health checks
            echo 'Waiting for services to be healthy...'
            for i in {1..30}; do
              if curl -f http://localhost/health >/dev/null 2>&1; then
                echo 'Web app is healthy'
                break
              fi
              echo 'Waiting for web app... (attempt \$i/30)'
              sleep 10
            done
            
            for i in {1..30}; do
              if curl -f http://localhost:3001/health >/dev/null 2>&1; then
                echo 'API server is healthy'
                break
              fi
              echo 'Waiting for API server... (attempt \$i/30)'
              sleep 10
            done
          "

      - name: üåê Update DNS (if configured)
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          if [[ -n "$CLOUDFLARE_API_TOKEN" && -n "$CLOUDFLARE_ZONE_ID" ]]; then
            echo "üåê Updating DNS records..."
            
            # Update A record to point to new server
            curl -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"type":"A","name":"${{ env.DOMAIN_NAME }}","content":"'$SERVER_IP'"}'
          else
            echo "‚ÑπÔ∏è Cloudflare credentials not configured, skipping DNS update"
          fi

  # ============================================================================
  # Deployment Summary & Notifications
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, deploy-to-server, create-server, detect-changes]
    if: always()
    steps:
      - name: üìã Generate Summary
        run: |
          echo "# üöÄ ATS Server Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Server status
          if [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "‚úÖ **New Server Created**: ${{ needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            echo "‚úÖ **Using Existing Server**: ${{ needs.infrastructure-check.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.create-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Server Creation Skipped**: No server exists and create_new_server=false" >> $GITHUB_STEP_SUMMARY
            echo "   - To deploy, set create_new_server=true in workflow inputs" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.result }}" == "failure" ]]; then
            echo "‚ùå **Infrastructure Check Failed**: Could not check for existing servers" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Build status
          if [[ "${{ needs.build-docker-images.result }}" == "success" ]]; then
            echo "‚úÖ **Docker Images Built and Pushed**" >> $GITHUB_STEP_SUMMARY
            echo "   - Web: ${{ needs.build-docker-images.outputs.web-image }}" >> $GITHUB_STEP_SUMMARY
            echo "   - API: ${{ needs.build-docker-images.outputs.api-image }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.build-docker-images.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Docker Build Skipped**: No code changes detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Deployment status
          if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
            echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê Access Points" >> $GITHUB_STEP_SUMMARY
            echo "- **Web Interface**: http://${{ env.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
            echo "- **API Server**: http://${{ env.DOMAIN_NAME }}:3001" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-to-server.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è **Deployment Skipped**: No server available" >> $GITHUB_STEP_SUMMARY
            echo "   - Create a server first by setting create_new_server=true" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì¢ Discord Notification
        if: env.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          STATUS="‚úÖ Success"
          if [[ "${{ needs.deploy-to-server.result }}" != "success" ]]; then
            STATUS="‚ùå Failed"
          fi
          
          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"üöÄ ATS Server Deployment\",
                \"description\": \"Deployment Status: $STATUS\",
                \"color\": 3066993,
                \"fields\": [
                  {\"name\": \"Domain\", \"value\": \"${{ env.DOMAIN_NAME }}\", \"inline\": true},
                  {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\", \"inline\": true}
                ]
              }]
            }" \
            "${{ secrets.DISCORD_WEBHOOK_URL }}"
