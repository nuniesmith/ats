name: üöÄ ATS Server Complete Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'What to deploy'
        required: true
        type: choice
        options:
          - 'full-deploy'          # Deploy both React web app and ATS server
          - 'web-only'             # Deploy only React web interface
          - 'docker-only'          # Deploy only Docker containers
          - 'ats-server-only'      # Deploy only ATS dedicated server
          - 'update-server'        # Update existing deployment
        default: 'docker-only'
      
      create_new_server:
        description: 'Create new Linode server for ATS'
        required: false
        type: boolean
        default: false
      
      server_type:
        description: 'Server type to create'
        required: false
        type: choice
        options:
          - 'g6-standard-2'        # 2GB RAM, 1 CPU (recommended for ATS)
          - 'g6-standard-4'        # 4GB RAM, 2 CPU (for multiple servers)
          - 'g6-standard-8'        # 8GB RAM, 4 CPU (for heavy mod loads)
        default: 'g6-standard-4'
      
      target_region:
        description: 'Linode region for server'
        required: false
        type: choice
        options:
          - 'us-east'              # New York/Newark
          - 'us-central'           # Dallas
          - 'us-west'              # Los Angeles
          - 'ca-central'           # Toronto
          - 'eu-west'              # London
        default: 'ca-central'

env:
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'docker-only' }}
  CREATE_NEW_SERVER: ${{ github.event.inputs.create_new_server || 'false' }}
  SERVER_TYPE: ${{ github.event.inputs.server_type || 'g6-standard-4' }}
  TARGET_REGION: ${{ github.event.inputs.target_region || 'ca-central' }}
  DOMAIN_NAME: ats.7gram.xyz
  NODE_VERSION: '18'
  DOCKER_REPO: nuniesmith/ats

jobs:
  # ============================================================================
  # Detect File Changes
  # ============================================================================
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      web-changed: ${{ steps.changes.outputs.web }}
      api-changed: ${{ steps.changes.outputs.api }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check for file changes
        id: changes
        run: |
          # Check if this is a manual trigger or first push
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - building all"
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "workflow=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"
          
          # Check for web changes
          if echo "$CHANGED_FILES" | grep -E '^src/web/|^package.*\.json$' >/dev/null 2>&1; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "üì¶ Web app changes detected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for API changes
          if echo "$CHANGED_FILES" | grep -E '^src/api/|^package.*\.json$' >/dev/null 2>&1; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "üîß API changes detected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Docker/deployment changes
          if echo "$CHANGED_FILES" | grep -E '^docker-compose|Dockerfile|\.dockerignore' >/dev/null 2>&1; then
            echo "docker=true" >> $GITHUB_OUTPUT
            echo "üê≥ Docker changes detected"
          else
            echo "docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for workflow changes
          if echo "$CHANGED_FILES" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
            echo "workflow=true" >> $GITHUB_OUTPUT
            echo "‚öôÔ∏è Workflow changes detected"
          else
            echo "workflow=false" >> $GITHUB_OUTPUT
          fi
          
          # If any changes detected, enable docker builds
          if [[ "$(echo "$CHANGED_FILES" | grep -E '^src/|Dockerfile|docker-compose|\.github/workflows/' | wc -l)" -gt 0 ]]; then
            echo "docker=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Infrastructure Check & Setup
  # ============================================================================
  infrastructure-check:
    name: üèóÔ∏è Infrastructure Check
    runs-on: ubuntu-latest
    needs: detect-changes
    outputs:
      server-exists: ${{ steps.check-server.outputs.exists }}
      server-ip: ${{ steps.check-server.outputs.ip }}
      server-status: ${{ steps.check-server.outputs.status }}
      should-create: ${{ steps.decision.outputs.create }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Check Existing Linode Servers
        id: check-server
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
        run: |
          echo "üîç Checking for existing ATS servers..."
          
          # Skip if no Linode token provided
          if [[ -z "$LINODE_TOKEN" ]]; then
            echo "‚ö†Ô∏è No Linode token provided - skipping server check"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Install Linode CLI
          pip3 install linode-cli
          
          # Configure Linode CLI non-interactively
          mkdir -p ~/.config/linode-cli
          cat > ~/.config/linode-cli/config << EOF
          [DEFAULT]
          token = $LINODE_TOKEN
          region = us-east
          type = g6-nanode-1
          image = linode/ubuntu22.04
          authorized_users = 
          EOF
          
          # Check for existing servers
          SERVER_INFO=$(linode-cli linodes list --text --no-headers --format="label,ipv4,status" | grep "ats-server" || true)
          
          if [ -n "$SERVER_INFO" ]; then
            SERVER_IP=$(echo "$SERVER_INFO" | awk '{print $2}' | tr -d '[]')
            SERVER_STATUS=$(echo "$SERVER_INFO" | awk '{print $3}')
            
            echo "‚úÖ Found existing ATS server:"
            echo "   Public IP: $SERVER_IP"
            echo "   Status: $SERVER_STATUS"
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "status=$SERVER_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No existing ATS server found"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
          fi

      - name: ü§î Deployment Decision
        id: decision
        run: |
          echo "ü§î Making deployment decisions..."
          
          SERVER_EXISTS="${{ steps.check-server.outputs.exists }}"
          CREATE_NEW="${{ env.CREATE_NEW_SERVER }}"
          
          echo "Server exists: $SERVER_EXISTS"
          echo "Create new requested: $CREATE_NEW"
          
          if [[ "$SERVER_EXISTS" == "true" ]]; then
            echo "‚úÖ Server exists - will use existing server"
            echo "create=false" >> $GITHUB_OUTPUT
          elif [[ "$CREATE_NEW" == "true" ]]; then
            echo "üî® Will create new server"
            echo "create=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No server exists and create_new_server=false"
            echo "create=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Create New Server (if needed)
  # ============================================================================
  create-server:
    name: üî® Create ATS Server
    runs-on: ubuntu-latest
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.should-create == 'true'
    outputs:
      server-ip: ${{ steps.create.outputs.ip }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üî® Create Linode Server
        id: create
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üî® Creating new ATS server..."
          
          # Install Linode CLI
          pip3 install linode-cli
          
          # Configure Linode CLI non-interactively
          mkdir -p ~/.config/linode-cli
          cat > ~/.config/linode-cli/config << EOF
          [DEFAULT]
          token = $LINODE_TOKEN
          region = us-east
          type = g6-nanode-1
          image = linode/ubuntu22.04
          authorized_users = 
          EOF
          
          # Create the server
          RESULT=$(linode-cli linodes create \
            --label "ats-server" \
            --region "${{ env.TARGET_REGION }}" \
            --type "${{ env.SERVER_TYPE }}" \
            --image "linode/ubuntu22.04" \
            --root_pass "$ATS_ROOT_PASSWORD" \
            --json)
          
          SERVER_IP=$(echo "$RESULT" | jq -r '.[0].ipv4[0]')
          echo "‚úÖ Server created with IP: $SERVER_IP"
          echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
          
          # Wait for server to boot
          echo "‚è≥ Waiting for server to boot..."
          sleep 120

      - name: üîß Initial Server Setup
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üîß Setting up server basics..."
          
          # Wait for SSH to be available
          for i in {1..10}; do
            if sshpass -p "$ATS_ROOT_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "echo 'Server ready'"; then
              echo "‚úÖ SSH connection established"
              break
            fi
            echo "‚è≥ Waiting for SSH... (attempt $i/10)"
            sleep 30
          done
          
          # Basic server setup
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            # Update system
            apt update && apt upgrade -y
            
            # Install essential packages
            apt install -y curl wget git unzip nginx
            
            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            systemctl enable docker
            systemctl start docker
            
            # Install Docker Compose
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
            
            # Configure firewall
            ufw allow ssh
            ufw allow http
            ufw allow https
            ufw --force enable
          EOF

  # ============================================================================
  # Build and Push Docker Images to DockerHub
  # ============================================================================
  build-docker-images:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
       (needs.detect-changes.outputs.docker-changed == 'true' || 
        needs.detect-changes.outputs.web-changed == 'true' || 
        needs.detect-changes.outputs.api-changed == 'true' ||
        github.event_name == 'workflow_dispatch'))
    outputs:
      web-image: ${{ steps.meta.outputs.web-image }}
      api-image: ${{ steps.meta.outputs.api-image }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üè∑Ô∏è Generate image tags
        id: meta
        run: |
          # Generate version tag
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="latest"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="pr-${{ github.event.number }}"
          fi
          
          WEB_IMAGE="${{ env.DOCKER_REPO }}:web-${VERSION}"
          API_IMAGE="${{ env.DOCKER_REPO }}:api-${VERSION}"
          
          echo "web-image=${WEB_IMAGE}" >> $GITHUB_OUTPUT
          echo "api-image=${API_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Will build:"
          echo "  Web: ${WEB_IMAGE}"
          echo "  API: ${API_IMAGE}"

      - name: üèóÔ∏è Build and Push React Web App
        if: needs.detect-changes.outputs.web-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/web
          file: ./src/web/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.web-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_API_URL=http://localhost/api
            VITE_SOCKET_URL=http://localhost

      - name: üèóÔ∏è Build and Push API Server
        if: needs.detect-changes.outputs.api-changed == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./src/api
          file: ./src/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.api-image }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy-to-server:
    name: üöÄ Deploy to ATS Server
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, create-server, detect-changes]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["docker-only", "full-deploy", "web-only"]'), github.event.inputs.deployment_mode || 'docker-only') &&
      (needs.build-docker-images.result == 'success' || needs.build-docker-images.result == 'skipped')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üéØ Determine Target Server
        id: target
        run: |
          if [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
            echo "Using existing server: $SERVER_IP"
          else
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
            echo "Using new server: $SERVER_IP"
          fi
          echo "server-ip=$SERVER_IP" >> $GITHUB_OUTPUT

      - name: üì¶ Deploy Docker Stack
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          WEB_IMAGE: ${{ needs.build-docker-images.outputs.web-image }}
          API_IMAGE: ${{ needs.build-docker-images.outputs.api-image }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üöÄ Deploying to server: $SERVER_IP"
          echo "üê≥ Using images:"
          echo "   Web: ${WEB_IMAGE:-nuniesmith/ats:web-latest}"
          echo "   API: ${API_IMAGE:-nuniesmith/ats:api-latest}"
          
          # Create deployment directory
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "mkdir -p /opt/ats"
          
          # Copy deployment files
          sshpass -p "$ATS_ROOT_PASSWORD" scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@$SERVER_IP:/opt/ats/docker-compose.yml
          
          # Create environment file
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "cat > /opt/ats/.env << 'EOF'
          NODE_ENV=production
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ env.DOMAIN_NAME }}
          ATS_DEFAULT_PASSWORD=${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID=3530633316
          WEB_IMAGE=${WEB_IMAGE:-nuniesmith/ats:web-latest}
          API_IMAGE=${API_IMAGE:-nuniesmith/ats:api-latest}
          CLOUDFLARE_API_TOKEN=${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID=${{ secrets.CLOUDFLARE_ZONE_ID }}
          DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }}
          EOF"
          
          # Deploy the stack
          sshpass -p "$ATS_ROOT_PASSWORD" ssh -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /opt/ats
            docker-compose pull
            docker-compose up -d
            
            # Wait for health checks
            echo 'Waiting for services to be healthy...'
            for i in {1..30}; do
              if curl -f http://localhost/health >/dev/null 2>&1; then
                echo 'Web app is healthy'
                break
              fi
              echo 'Waiting for web app... (attempt \$i/30)'
              sleep 10
            done
            
            for i in {1..30}; do
              if curl -f http://localhost:3001/health >/dev/null 2>&1; then
                echo 'API server is healthy'
                break
              fi
              echo 'Waiting for API server... (attempt \$i/30)'
              sleep 10
            done
          "

      - name: üåê Update DNS (if configured)
        env:
          SERVER_IP: ${{ steps.target.outputs.server-ip }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          if [[ -n "$CLOUDFLARE_API_TOKEN" && -n "$CLOUDFLARE_ZONE_ID" ]]; then
            echo "üåê Updating DNS records..."
            
            # Update A record to point to new server
            curl -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"type":"A","name":"${{ env.DOMAIN_NAME }}","content":"'$SERVER_IP'"}'
          else
            echo "‚ÑπÔ∏è Cloudflare credentials not configured, skipping DNS update"
          fi

  # ============================================================================
  # Deployment Summary & Notifications
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-check, build-docker-images, deploy-to-server, create-server, detect-changes]
    if: always()
    steps:
      - name: üìã Generate Summary
        run: |
          echo "# üöÄ ATS Server Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "‚úÖ **New Server Created**: ${{ needs.create-server.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            echo "‚úÖ **Using Existing Server**: ${{ needs.infrastructure-check.outputs.server-ip }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.build-docker-images.result }}" == "success" ]]; then
            echo "‚úÖ **Docker Images Built and Pushed**" >> $GITHUB_STEP_SUMMARY
            echo "   - Web: ${{ needs.build-docker-images.outputs.web-image }}" >> $GITHUB_STEP_SUMMARY
            echo "   - API: ${{ needs.build-docker-images.outputs.api-image }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-to-server.result }}" == "success" ]]; then
            echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê Access Points" >> $GITHUB_STEP_SUMMARY
            echo "- **Web Interface**: http://${{ env.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
            echo "- **API Server**: http://${{ env.DOMAIN_NAME }}:3001" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì¢ Discord Notification
        if: env.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          STATUS="‚úÖ Success"
          if [[ "${{ needs.deploy-to-server.result }}" != "success" ]]; then
            STATUS="‚ùå Failed"
          fi
          
          curl -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"üöÄ ATS Server Deployment\",
                \"description\": \"Deployment Status: $STATUS\",
                \"color\": 3066993,
                \"fields\": [
                  {\"name\": \"Domain\", \"value\": \"${{ env.DOMAIN_NAME }}\", \"inline\": true},
                  {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\", \"inline\": true}
                ]
              }]
            }" \
            "${{ secrets.DISCORD_WEBHOOK_URL }}"
