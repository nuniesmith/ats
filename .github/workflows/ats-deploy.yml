# Example for ATS Repository
# File: .github/workflows/deploy.yml in your ATS repo

name: üöÄ Manage ATS Game Server

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - 'deploy'
          - 'destroy'
          - 'health-check'
          - 'restart'
        default: 'deploy'
      
      deployment_mode:
        description: 'Deployment mode'
        required: false
        type: choice
        options:
          - 'full-deploy'
          - 'update-only'
          - 'restart-only'
          - 'code-only'
        default: 'update-only'
      
      # üéØ Advanced Options
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      build_docker_on_changes:
        description: 'Only build Docker if code/Dockerfile changed'
        required: false
        type: boolean
        default: true
      
      overwrite_server:
        description: 'Destroy and recreate Linode server'
        required: false
        type: boolean
        default: true
      
      # Destroy Options (for destroy action)
      destroy_scope:
        description: 'What to destroy (for destroy action)'
        required: false
        type: choice
        options:
          - 'service-only'
          - 'full-server'
          - 'reset-service'
        default: 'service-only'
      
      confirm_destruction:
        description: 'Type "DESTROY" to confirm destruction'
        required: false
        type: string

jobs:
  manage-ats:
    # üëá This calls your unified actions repository
    uses: nuniesmith/actions/.github/workflows/deploy.yml@main
    with:
      service_name: ats
      action_type: ${{ github.event.inputs.action_type || 'deploy' }}
      deployment_mode: ${{ github.event.inputs.deployment_mode || 'update-only' }}
      skip_tests: ${{ github.event.inputs.skip_tests || false }}
      skip_docker_build: ${{ github.event.inputs.skip_docker_build || false }}
      build_docker_on_changes: ${{ github.event.inputs.build_docker_on_changes || true }}
      overwrite_server: ${{ github.event.inputs.overwrite_server || true }}
      destroy_scope: ${{ github.event.inputs.destroy_scope || 'service-only' }}
      confirm_destruction: ${{ github.event.inputs.confirm_destruction || '' }}
      server_type: g6-standard-4  # 8GB RAM for better performance
      target_region: ca-central
      domain_suffix: 7gram.xyz
      enable_monitoring: true
      enable_backups: false
    secrets:
      LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
      SERVICE_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
      JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
      ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      TAILSCALE_OAUTH_CLIENT_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
      TAILSCALE_OAUTH_SECRET: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
      NETDATA_CLAIM_TOKEN: ${{ secrets.NETDATA_CLAIM_TOKEN }}
      NETDATA_CLAIM_ROOM: ${{ secrets.NETDATA_CLAIM_ROOM }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}

  # ATS-specific post-deployment
  ats-post-deploy:
    name: üéÆ ATS Game Server Setup
    runs-on: ubuntu-latest
    needs: manage-ats
    if: success() && (github.event.inputs.action_type == 'deploy' || github.event.inputs.action_type == '')
    
    steps:
      - name: üì• Checkout ATS Repository
        uses: actions/checkout@v4

      - name: üåê Update Cloudflare DNS Records
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        if: env.CLOUDFLARE_API_TOKEN != '' && env.CLOUDFLARE_ZONE_ID != ''
        run: |
          echo "üåê Updating Cloudflare DNS records for ATS server..."
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq >/dev/null 2>&1
          
          # Get the Tailscale IP from the infrastructure job output
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          if [[ -z "$TAILSCALE_IP" || "$TAILSCALE_IP" == "unknown" || "$TAILSCALE_IP" == "pending" ]]; then
            echo "‚ö†Ô∏è No valid Tailscale IP available: '$TAILSCALE_IP'"
            echo "Skipping DNS update"
            exit 0
          fi
          
          echo "üîó Using Tailscale IP: $TAILSCALE_IP"
          
          # Update A record for ats.7gram.xyz
          echo "üìù Updating A record for ats.7gram.xyz..."
          
          # Get existing record ID first
          RECORD_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?type=A&name=ats.7gram.xyz" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          
          if ! echo "$RECORD_RESPONSE" | jq . >/dev/null 2>&1; then
            echo "‚ùå Failed to parse Cloudflare API response"
            echo "Response: $RECORD_RESPONSE"
            exit 1
          fi
          
          RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id // empty')
          
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" ]]; then
            echo "üìù Updating existing A record (ID: $RECORD_ID)..."
            UPDATE_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"A\",
                \"name\": \"ats\",
                \"content\": \"$TAILSCALE_IP\",
                \"ttl\": 300,
                \"comment\": \"ATS Game Server - Updated by GitHub Actions\"
              }")
            
            SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.success // false')
            if [[ "$SUCCESS" == "true" ]]; then
              echo "‚úÖ A record updated successfully"
            else
              echo "‚ùå Failed to update A record"
              echo "Response: $UPDATE_RESPONSE"
            fi
          else
            echo "üìù Creating new A record..."
            CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"A\",
                \"name\": \"ats\",
                \"content\": \"$TAILSCALE_IP\",
                \"ttl\": 300,
                \"comment\": \"ATS Game Server - Created by GitHub Actions\"
              }")
            
            SUCCESS=$(echo "$CREATE_RESPONSE" | jq -r '.success // false')
            if [[ "$SUCCESS" == "true" ]]; then
              echo "‚úÖ A record created successfully"
            else
              echo "‚ùå Failed to create A record"
              echo "Response: $CREATE_RESPONSE"
            fi
          fi
          
          echo "‚úÖ DNS update completed - ats.7gram.xyz now points to $TAILSCALE_IP"
          echo "‚è≥ DNS propagation may take a few minutes..."

      - name: üéÆ Configure Game Server
        env:
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üéÆ Configuring ATS game server..."
          
          # Install sshpass for password authentication
          sudo apt-get update && sudo apt-get install -y sshpass >/dev/null 2>&1
          
          # Get the server IP information
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          echo "üîó Server Tailscale IP: $TAILSCALE_IP"
          
          # Try to determine server connection method
          echo "üîç Determining server connection method..."
          
          # Give SSH service time to be ready after Stage 2
          echo "‚è≥ Waiting for SSH service to be ready..."
          sleep 15
          
          # Get server public IP as fallback
          SERVER_IP="${{ needs.manage-ats.outputs.server_ip }}"
          echo "üîó Server Public IP: $SERVER_IP"
          
          # Method 1: Try Tailscale IP directly (most reliable for GitHub Actions)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$TAILSCALE_IP "echo 'Connected via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            echo "‚úÖ Using Tailscale IP: $SERVER_HOST"
          # Method 2: Try public IP directly
          elif [[ -n "$SERVER_IP" && "$SERVER_IP" != "unknown" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$SERVER_IP "echo 'Connected via public IP'" 2>/dev/null; then
            SERVER_HOST="$SERVER_IP"
            echo "‚úÖ Using public IP: $SERVER_HOST"
          # Method 3: Try public domain (after DNS update)
          elif timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@ats.7gram.xyz "echo 'Connected via public domain'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
            echo "‚úÖ Using public domain: $SERVER_HOST"
          # Method 4: Try root user as fallback
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "echo 'Connected as root via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            SERVER_USER="root"
            echo "‚úÖ Using root@Tailscale IP: $SERVER_HOST (will setup ats_user)"
          else
            echo "‚ùå Could not connect to ATS server via any method"
            echo "üîç Tried:"
            echo "  - Tailscale IP: $TAILSCALE_IP"
            echo "  - Public IP: $SERVER_IP"  
            echo "  - Public domain: ats.7gram.xyz"
            echo "  - Root user fallback: root@$TAILSCALE_IP"
            echo "‚ö†Ô∏è Skipping game server configuration"
            exit 0
          fi
          
          # Set default user if not set
          SERVER_USER="${SERVER_USER:-ats_user}"
          echo "üîó Connecting as: $SERVER_USER@$SERVER_HOST"
          
          # If we connected as root, set up ats_user properly
          if [[ "$SERVER_USER" == "root" ]]; then
            echo "üîß Setting up ats_user access..."
            sshpass -e ssh -o StrictHostKeyChecking=no root@$SERVER_HOST "
              # Ensure ats_user exists and has proper setup
              id ats_user || useradd -m -s /bin/bash ats_user
              echo 'ats_user:${{ secrets.ACTIONS_USER_PASSWORD }}' | chpasswd
              usermod -aG docker ats_user
              mkdir -p /home/ats_user/.ssh
              chmod 700 /home/ats_user/.ssh  
              chown ats_user:ats_user /home/ats_user/.ssh
            "
            # Now switch to ats_user for the rest
            SERVER_USER="ats_user"
          fi
          
          echo "üîÑ Waiting for services to be ready..."
          sleep 30
          
          # Clone or update the ATS repository
          echo "ÔøΩ Setting up ATS repository..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            # Ensure git is available and configured
            git --version || { echo 'Git not found'; exit 1; }
            
            # Remove existing directory if it exists and clone fresh
            rm -rf /home/ats_user/ats
            
            # Clone the ATS repository (public repo, no auth needed)
            echo 'Cloning ATS repository from GitHub...'
            git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats || {
              echo 'Failed to clone repository, trying alternative methods...'
              # Try with explicit HTTPS
              git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats --depth 1 || {
                echo 'Git clone failed completely'
                exit 1
              }
            }
            
            # Change ownership to ats_user if we're running as root
            if [[ \$(whoami) == 'root' ]]; then
              chown -R ats_user:ats_user /home/ats_user/ats
            fi
            
            # Change to the repository directory
            cd /home/ats_user/ats
            
            echo 'Repository cloned successfully!'
            echo 'Repository contents:'
            ls -la
            
            echo 'Git repository info:'
            git log --oneline -5 || echo 'Git log unavailable'
          " || {
            echo "‚ö†Ô∏è Failed to clone ATS repository"
            exit 1
          }
          
          # Upload any local configs if they exist (to override defaults)
          if [[ -f "config/server_config.sii" ]]; then
            echo "üìÅ Uploading custom server configuration..."
            sshpass -e scp -o StrictHostKeyChecking=no config/server_config.sii $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload server config"
            }
          fi
          
          if [[ -d "config/" ]]; then
            echo "üìÅ Uploading additional custom configurations..."
            sshpass -e scp -r -o StrictHostKeyChecking=no config/* $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload some configs"
            }
          fi
          
          # Pull Docker images and start services
          echo "üê≥ Starting ATS services from repository..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            cd /home/ats_user/ats || exit 1
            
            echo 'Current directory contents:'
            ls -la
            
            # Advanced Docker networking fixes
            echo 'üîß Applying comprehensive Docker network fixes...'
            
            # Stop any existing services and clean up networks
            echo 'üßπ Cleaning up existing services...'
            
            # Determine which Docker Compose command to use for cleanup
            COMPOSE_CMD=\"\"
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker compose\"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker-compose\"
            fi
            
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              \$COMPOSE_CMD down --remove-orphans 2>/dev/null || true
            else
              echo 'No compose command available for cleanup'
            fi
            
            docker network prune -f 2>/dev/null || true
            
            # Check for iptables issues and fix them comprehensively
            echo 'üîç Checking and fixing iptables configuration...'
            if ! sudo iptables -t nat -L DOCKER >/dev/null 2>&1; then
              echo '‚ö†Ô∏è Docker iptables chains missing, performing complete reset...'
              
              # Stop Docker completely
              sudo systemctl stop docker
              sudo systemctl stop docker.socket
              
              # Clean up all Docker-related iptables rules and chains
              echo 'üßπ Cleaning iptables...'
              sudo iptables -t nat -F DOCKER 2>/dev/null || true
              sudo iptables -t filter -F DOCKER 2>/dev/null || true
              sudo iptables -t filter -F DOCKER-ISOLATION-STAGE-1 2>/dev/null || true
              sudo iptables -t filter -F DOCKER-ISOLATION-STAGE-2 2>/dev/null || true
              sudo iptables -t filter -F DOCKER-USER 2>/dev/null || true
              
              # Remove Docker chains
              sudo iptables -t nat -X DOCKER 2>/dev/null || true
              sudo iptables -t filter -X DOCKER 2>/dev/null || true
              sudo iptables -t filter -X DOCKER-ISOLATION-STAGE-1 2>/dev/null || true
              sudo iptables -t filter -X DOCKER-ISOLATION-STAGE-2 2>/dev/null || true
              sudo iptables -t filter -X DOCKER-USER 2>/dev/null || true
              
              # Remove Docker network interfaces and data
              echo 'üßπ Cleaning network interfaces...'
              for interface in \$(ip link show | grep br- | cut -d: -f2 | tr -d \" \"); do
                echo \"  Removing bridge: \$interface\"
                sudo ip link delete \"\$interface\" 2>/dev/null || true
              done
              
              # Clean Docker network data
              sudo rm -rf /var/lib/docker/network/* 2>/dev/null || true
              sudo rm -rf /var/lib/docker/containers/*/network 2>/dev/null || true
              
              echo '‚úÖ Network cleanup completed'
            fi
            
            # Restart Docker with clean state
            echo 'üîÑ Restarting Docker with clean network state...'
            sudo systemctl start docker.socket
            sudo systemctl start docker
            sleep 15
            
            # Verify Docker is working properly
            if docker info >/dev/null 2>&1; then
              echo '‚úÖ Docker restarted successfully'
              
              # Test network creation capability
              if docker network create test-network >/dev/null 2>&1; then
                echo '‚úÖ Network creation test passed'
                docker network rm test-network >/dev/null 2>&1
              else
                echo '‚ö†Ô∏è Network creation test failed, but continuing...'
              fi
            else
              echo '‚ùå Docker restart failed'
              sudo systemctl status docker
              exit 1
            fi
            
            # Pull the latest images
            echo 'Pulling Docker images...'
            
            # Use the same compose command for pulling
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              \$COMPOSE_CMD pull || echo 'Failed to pull some images (may not exist yet)'
            else
              echo 'No compose command available for pulling images'
            fi
            
            # Start the services with comprehensive error handling
            echo 'Starting ATS services...'
            if [[ -n \"\$COMPOSE_CMD\" ]] && \$COMPOSE_CMD up -d; then
              echo '‚úÖ Docker Compose services started successfully'
            else
              echo '‚ö†Ô∏è Docker Compose failed, trying recovery methods...'
              
              # Method 1: Network reset and retry
              echo 'üîß Attempting network reset and retry...'
              docker network ls -q | xargs -r docker network rm 2>/dev/null || true
              sudo systemctl restart docker
              sleep 10
              
              if [[ -n \"\$COMPOSE_CMD\" ]] && \$COMPOSE_CMD up -d --force-recreate; then
                echo '‚úÖ Services started after network reset'
              else
                echo '‚ö†Ô∏è Compose still failing, trying alternative startup methods...'
                
                # Method 2: Script-based startup
                if [[ -f start.sh ]]; then
                  echo 'üöÄ Using start.sh script...'
                  chmod +x start.sh && ./start.sh
                elif [[ -f deploy.sh ]]; then
                  echo 'üöÄ Using deploy.sh script...'
                  chmod +x deploy.sh && ./deploy.sh
                elif [[ -f run.sh ]]; then
                  echo 'üöÄ Using run.sh script...'
                  chmod +x run.sh && ./run.sh
                else
                  # Method 3: Manual container startup
                  echo 'üîß Attempting manual container startup...'
                  
                  IMAGES=\$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'ats|web|api' | head -5)
                  if [[ -n \"\$IMAGES\" ]]; then
                    echo 'üìã Found ATS images for manual startup:'
                    echo \"\$IMAGES\"
                    
                    # Clean up any existing containers
                    docker stop ats-web ats-api ats-server ats-redis 2>/dev/null || true
                    docker rm ats-web ats-api ats-server ats-redis 2>/dev/null || true
                    
                    # Start Redis first (if available)
                    if echo \"\$IMAGES\" | grep -q redis; then
                      echo 'üî¥ Starting Redis...'
                      docker run -d --name ats-redis --restart unless-stopped -p 6379:6379 redis:7-alpine && \\
                        echo '‚úÖ Redis started' || echo '‚ö†Ô∏è Redis startup failed'
                      sleep 3
                    fi
                    
                    # Start web interface
                    WEB_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'web|nginx' | head -1)
                    if [[ -n \"\$WEB_IMAGE\" ]]; then
                      echo \"üåê Starting web interface: \$WEB_IMAGE\"
                      docker run -d --name ats-web --restart unless-stopped -p 80:80 -p 8080:80 \"\$WEB_IMAGE\" && \\
                        echo '‚úÖ Web interface started' || echo '‚ö†Ô∏è Web startup failed'
                    fi
                    
                    # Start API service
                    API_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'api|server' | head -1)
                    if [[ -n \"\$API_IMAGE\" ]]; then
                      echo \"üîß Starting API service: \$API_IMAGE\"
                      docker run -d --name ats-api --restart unless-stopped -p 3001:3001 -p 27015:27015 \"\$API_IMAGE\" && \\
                        echo '‚úÖ API service started' || echo '‚ö†Ô∏è API startup failed'
                    fi
                    
                    # Start dedicated game server (if different from API)
                    SERVER_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'server|game' | grep -v api | head -1)
                    if [[ -n \"\$SERVER_IMAGE\" && \"\$SERVER_IMAGE\" != \"\$API_IMAGE\" ]]; then
                      echo \"üéÆ Starting game server: \$SERVER_IMAGE\"
                      docker run -d --name ats-server --restart unless-stopped -p 27015:27015/tcp -p 27015:27015/udp \"\$SERVER_IMAGE\" && \\
                        echo '‚úÖ Game server started' || echo '‚ö†Ô∏è Game server startup failed'
                    fi
                    
                    sleep 10  # Wait for containers to stabilize
                    
                  else
                    echo '‚ùå No ATS Docker images found for manual startup'
                    echo 'üìã Available images:'
                    docker images | head -10
                  fi
                fi
              fi
            fi
            
            # Show final status
            echo ''
            echo 'üîç Checking Docker services status...'
            
            # Wait for services to fully start
            echo "‚è±Ô∏è Waiting for services to initialize..."
            sleep 15
            
            # ===================================
            # COMPREHENSIVE SERVICE VERIFICATION
            # ===================================
            
            echo ''
            echo 'üìä === SERVICE VERIFICATION REPORT ==='
            
            # Check running containers
            echo 'üìã Running containers:'
            CONTAINERS=\$(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}')
            if [[ -n \"\$CONTAINERS\" ]]; then
              echo \"\$CONTAINERS\"
            else
              echo '‚ùå No containers running'
            fi
            echo ''
            
            # Port connectivity tests
            echo 'üîå Port connectivity tests:'
            PORTS=(80 443 8080 3000 3001 27015)
            for PORT in \"\${PORTS[@]}\"; do
              if netstat -tlnp 2>/dev/null | grep -q \":$PORT \"; then
                echo \"‚úÖ Port \$PORT: LISTENING\"
              else
                echo \"‚ùå Port \$PORT: NOT LISTENING\"
              fi
            done
            echo ''
            
            # Service health checks
            echo 'üè• Service health checks:'
            
            # Web interface tests
            if curl -s --max-time 10 \"http://localhost\" >/dev/null 2>&1; then
              echo '‚úÖ Web interface (port 80): HEALTHY'
              WEB_TITLE=\$(curl -s --max-time 5 \"http://localhost\" | grep -oP '<title>\\K[^<]+' | head -1)
              [[ -n \"\$WEB_TITLE\" ]] && echo \"   üìÑ Page title: \$WEB_TITLE\"
            elif curl -s --max-time 10 \"http://localhost:8080\" >/dev/null 2>&1; then
              echo '‚úÖ Web interface (port 8080): HEALTHY'
            else
              echo '‚ùå Web interface: NOT RESPONDING'
            fi
            
            # API health checks
            if curl -s --max-time 10 \"http://localhost:3000/health\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3000): HEALTHY'
            elif curl -s --max-time 10 \"http://localhost:3001/health\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3001): HEALTHY'
            elif curl -s --max-time 10 \"http://localhost:3000\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3000): RESPONDING'
            elif curl -s --max-time 10 \"http://localhost:3001\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3001): RESPONDING'
            else
              echo '‚ùå API service: NOT RESPONDING'
            fi
            
            # Game server connectivity
            if netstat -tlnp 2>/dev/null | grep -q ':27015 '; then
              echo '‚úÖ Game server (port 27015): LISTENING'
              # Test UDP port if possible
              if netstat -ulnp 2>/dev/null | grep -q ':27015 '; then
                echo '‚úÖ Game server UDP (port 27015): LISTENING'
              fi
            else
              echo '‚ùå Game server (port 27015): NOT LISTENING'
            fi
            echo ''
            
            # Resource usage monitoring
            echo 'üìà Resource usage:'
            echo \"üíæ Memory: \$(free -h | grep '^Mem' | awk '{print \$3\"/\"\$2}')\"
            echo \"üíø Disk: \$(df -h / | tail -1 | awk '{print \$3\"/\"\$2\" (\"\$5\" used)\"}')\"
            echo \"üîÑ Load: \$(uptime | awk -F'load average:' '{print \$2}' | xargs)\"
            echo ''
            
            # Docker system info
            echo 'üê≥ Docker system status:'
            echo \"üì¶ Containers: \$(docker ps -q | wc -l) running, \$(docker ps -aq | wc -l) total\"
            echo \"üñºÔ∏è  Images: \$(docker images -q | wc -l) total\"
            echo \"üåê Networks: \$(docker network ls -q | wc -l) total\"
            echo \"üíæ Volumes: \$(docker volume ls -q | wc -l) total\"
            echo ''
            
            # Docker Compose service verification
            echo 'üêô Docker Compose services:'
            
            # Determine which Docker Compose command to use
            COMPOSE_CMD=\"\"
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker compose\"
              echo \"Using Docker Compose V2: docker compose\"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker-compose\"
              echo \"Using Docker Compose V1: docker-compose\"
            else
              echo \"‚ùå No Docker Compose command available\"
            fi
            
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              # Use more robust commands that handle errors better
              SERVICES_UP=\$(\$COMPOSE_CMD ps -q 2>/dev/null | wc -l || echo \"0\")
              TOTAL_SERVICES=\$(\$COMPOSE_CMD config --services 2>/dev/null | wc -l || echo \"0\")
              
              echo \"üìä Services status: \$SERVICES_UP/\$TOTAL_SERVICES running\"
              
              if [[ \"\$SERVICES_UP\" -gt 0 ]]; then
                echo \"‚úÖ Some Docker services are running\"
                \$COMPOSE_CMD ps 2>/dev/null || echo 'Could not get compose status'
                
                # Check logs for any obvious errors
                echo \"üìù Quick log check for errors:\"
                \$COMPOSE_CMD logs --tail 20 2>/dev/null | grep -i \"error\\|fail\\|exception\" | head -5 || echo \"No obvious errors in recent logs\"
                
              else
                echo \"‚ùå No Docker Compose services are running\"
                \$COMPOSE_CMD ps 2>/dev/null || echo 'Docker compose not responding'
                
                # Check if any ATS containers are running manually
                MANUAL_CONTAINERS=\$(docker ps --filter \"name=ats\" --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
                if [[ \"\$MANUAL_CONTAINERS\" -gt 0 ]]; then
                  echo \"üìã Found \$MANUAL_CONTAINERS manually started ATS containers:\"
                  docker ps --filter \"name=ats\" --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
                fi
              fi
            else
              echo 'Docker compose command not available, checking containers directly'
              
              # Check for any running containers
              RUNNING_CONTAINERS=\$(docker ps --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
              if [[ \"\$RUNNING_CONTAINERS\" -gt 0 ]]; then
                echo \"üìã Found \$RUNNING_CONTAINERS running containers:\"
                docker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
              else
                echo \"‚ùå No containers running\"
              fi
            fi
            echo ''
            
            # Service accessibility summary
            echo 'üåç Service accessibility:'
            
            # Test different access methods
            echo 'üîó Access URLs to test:'
            
            # Get server IPs
            TAILSCALE_IP=\$(hostname -I | awk '{print \$1}' | head -1)
            PUBLIC_IP=\$(curl -s --max-time 10 ifconfig.me 2>/dev/null || curl -s --max-time 10 icanhazip.com 2>/dev/null || echo 'unavailable')
            
            if [[ -n \"\$TAILSCALE_IP\" && \"\$TAILSCALE_IP\" != \"127.0.0.1\" ]]; then
              echo \"   üìç Tailscale IP: http://\$TAILSCALE_IP\"
              echo \"   üìç Tailscale IP:8080: http://\$TAILSCALE_IP:8080\"
            fi
            
            if [[ -n \"\$PUBLIC_IP\" && \"\$PUBLIC_IP\" != \"unavailable\" ]]; then
              echo \"   üåê Public IP: http://\$PUBLIC_IP\"
              echo \"   üåê Public IP:8080: http://\$PUBLIC_IP:8080\"
            fi
            
            # Domain testing if configured
            DOMAIN_NAME=\"ats.7gram.xyz\"  # Fixed domain name for ATS
            if [[ -n \"\$DOMAIN_NAME\" ]]; then
              echo \"   üè∑Ô∏è  Domain: http://\$DOMAIN_NAME\"
              echo \"   üè∑Ô∏è  Domain HTTPS: https://\$DOMAIN_NAME\"
              
              # Test domain resolution
              if nslookup \"\$DOMAIN_NAME\" >/dev/null 2>&1; then
                echo '   ‚úÖ Domain DNS resolution: OK'
              else
                echo '   ‚ùå Domain DNS resolution: FAILED'
              fi
            fi
            echo ''
            
            # Final status summary
            RUNNING_COUNT=\$(docker ps -q | wc -l)
            if [[ \$RUNNING_COUNT -gt 0 ]]; then
              echo \"üéâ === DEPLOYMENT SUCCESSFUL ===\\n‚ÑπÔ∏è  \$RUNNING_COUNT Docker containers are running\"
              
              # Show primary access method
              if [[ -n \"\$TAILSCALE_IP\" && \"\$TAILSCALE_IP\" != \"127.0.0.1\" ]]; then
                echo \"üîó Primary access: http://\$TAILSCALE_IP\"
              elif [[ -n \"\$PUBLIC_IP\" && \"\$PUBLIC_IP\" != \"unavailable\" ]]; then
                echo \"üîó Primary access: http://\$PUBLIC_IP\"
              fi
              
            else
              echo '‚ùå === DEPLOYMENT FAILED ===\\n‚ö†Ô∏è  No containers are running'
              echo ''
              echo 'üîç Troubleshooting information:'
              echo 'üìã All containers (including stopped):'
              docker ps -a
              echo ''
              echo 'üìã Recent Docker logs:'
              docker logs \$(docker ps -aq | head -1) 2>/dev/null | tail -20 || echo 'No logs available'
            fi
            
            # Show recent logs
            echo ''
            echo 'üìù Recent container logs:'
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              \$COMPOSE_CMD logs --tail=10 2>/dev/null || docker logs \$(docker ps -q | head -1) 2>/dev/null || echo 'Logs unavailable'
            else
              docker logs \$(docker ps -q | head -1) 2>/dev/null || echo 'Logs unavailable'
            fi
          " || {
            echo "‚ö†Ô∏è Failed to start ATS services"
          }

      - name: üß™ Test Game Server
        run: |
          echo "üß™ Testing ATS game server..."
          
          # Wait a bit for services to start and DNS to propagate
          echo "‚è≥ Waiting for services to start and DNS to propagate..."
          sleep 30
          
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          # Test web interface via multiple methods
          echo "üåê Testing web interface..."
          
          # Method 1: Test via Tailscale IP (most likely to work)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 80)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 8080)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -s http://$TAILSCALE_IP | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via Tailscale IP (contains expected content)"
          # Method 2: Test via public domain
          elif timeout 10 curl -f http://ats.7gram.xyz 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 80)"
          elif timeout 10 curl -f http://ats.7gram.xyz:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 8080)"
          elif timeout 10 curl -s http://ats.7gram.xyz | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via public domain (contains expected content)"
          else
            echo "‚ö†Ô∏è ATS web interface not responding via any method"
            echo "üîç Let's check what's actually running on the server..."
            
            # Get more detailed info about what's running
            if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
              echo "üìä Port scan results:"
              timeout 5 nmap -p 80,8080,27015,19999 $TAILSCALE_IP 2>/dev/null || echo "nmap not available"
              
              # Try to get a raw response
              echo "üìù Raw HTTP response:"
              timeout 5 curl -s http://$TAILSCALE_IP | head -10 || echo "No HTTP response"
            fi
          fi
          
          # Test game server port if accessible
          echo "üéÆ Testing game server port..."
          
          if timeout 5 bash -c "</dev/tcp/ats/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale hostname"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 5 bash -c "</dev/tcp/$TAILSCALE_IP/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale IP"
          elif timeout 5 bash -c "</dev/tcp/ats.7gram.xyz/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via public domain"
          else
            echo "‚ÑπÔ∏è Game server port not accessible externally (may be behind firewall or still starting)"
            echo "   This is normal if the game server only accepts connections from Tailscale network"
          fi
          
          echo "üéÆ ATS game server setup complete!"
          echo "üìä Access URLs:"
          echo "  - Tailscale: http://ats:8080 or http://$TAILSCALE_IP:8080"
          echo "  - Public: https://ats.7gram.xyz (after DNS propagation)"
          
          # Final deployment verification
          echo ""
          echo "üéØ Final Deployment Verification:"
          echo "================================"
          
          # Summary of what was accomplished
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
            echo "‚úÖ Server connected to Tailscale: $TAILSCALE_IP"
          else
            echo "‚ö†Ô∏è Tailscale connection status unclear"
          fi
          
          DNS_UPDATED="true"  # Assume DNS was updated in previous step
          if [[ -n "$DNS_UPDATED" && "$DNS_UPDATED" == "true" ]]; then
            echo "‚úÖ DNS record updated for ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è DNS update status unclear"
          fi
          
          # Check repository status
          sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "
            if [[ -d '/home/ats_user/ats/.git' ]]; then
              echo '‚úÖ ATS repository cloned successfully'
              cd /home/ats_user/ats && git log --oneline -1 | sed 's/^/    Latest commit: /'
            else
              echo '‚ö†Ô∏è ATS repository not found'
            fi
            
            RUNNING_CONTAINERS=\$(docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -v 'NAMES' | wc -l)
            if [ \"\$RUNNING_CONTAINERS\" -gt 0 ]; then
              echo '‚úÖ Docker services running: '\$RUNNING_CONTAINERS' containers active'
            else
              echo '‚ùå No Docker containers running'
            fi
          " 2>/dev/null || echo "‚ö†Ô∏è Could not verify repository and container status"
          
          echo ""
          echo "üåê Access Information:"
          echo "====================="
          echo "üîó Direct access: http://$TAILSCALE_IP"
          echo "üîó Direct access (alt port): http://$TAILSCALE_IP:8080"
          echo "üîó Public access: http://ats.7gram.xyz"
          echo "üîó Public access (alt port): http://ats.7gram.xyz:8080"
          echo ""
          echo "üìù Note: Services may take a few minutes to fully initialize"
          echo "üéÆ ATS game server should be accessible for multiplayer connections"

      - name: üìä Verify Netdata Cloud Connection
        env:
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üìä Verifying Netdata cloud connection..."
          
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          # Determine server connection method (same as before)
          if timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@$TAILSCALE_IP "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
          elif timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats.7gram.xyz "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è Cannot connect to check Netdata status"
            exit 0
          fi
          
          echo "üîç Checking Netdata status on $SERVER_HOST..."
          
          # Check if Netdata is running and accessible
          sshpass -e ssh -o StrictHostKeyChecking=no ats_user@$SERVER_HOST "
            echo 'üìä Netdata service status:'
            sudo systemctl is-active netdata && echo '‚úÖ Netdata service is active' || echo '‚ö†Ô∏è Netdata service is not active'
            
            echo ''
            echo 'üåê Testing Netdata web interface:'
            if curl -f http://localhost:19999/api/v1/info 2>/dev/null >/dev/null; then
              echo '‚úÖ Netdata web interface is accessible'
            else
              echo '‚ö†Ô∏è Netdata web interface is not accessible'
            fi
            
            echo ''
            echo '‚òÅÔ∏è Checking Netdata cloud connection:'
            if [[ -f /var/lib/netdata/cloud.d/token ]]; then
              echo '‚úÖ Netdata cloud token file exists'
            else
              echo '‚ö†Ô∏è Netdata cloud token file not found'
            fi
            
            # Check if claiming is successful
            if [[ -f /var/lib/netdata/registry/netdata.public.unique.id ]]; then
              echo '‚úÖ Netdata unique ID exists'
              NETDATA_ID=\$(cat /var/lib/netdata/registry/netdata.public.unique.id 2>/dev/null || echo 'unknown')
              echo 'Netdata ID: '\$NETDATA_ID
            else
              echo '‚ö†Ô∏è Netdata unique ID not found'
            fi
            
            # Try to reclaim if needed
            if [[ ! -f /var/lib/netdata/cloud.d/token ]]; then
              echo ''
              echo 'üîÑ Attempting to reclaim Netdata to cloud...'
              
              # Find the claim script
              CLAIM_SCRIPT=''
              for script_path in \"/usr/sbin/netdata-claim.sh\" \"/opt/netdata/bin/netdata-claim.sh\" \"/usr/libexec/netdata/netdata-claim.sh\" \"/usr/lib/netdata/netdata-claim.sh\"; do
                if [[ -f \"\$script_path\" ]]; then
                  CLAIM_SCRIPT=\$script_path
                  break
                fi
              done
              
              if [[ -z \"\$CLAIM_SCRIPT\" ]]; then
                CLAIM_SCRIPT=\$(find /usr /opt -name \"netdata-claim.sh\" 2>/dev/null | head -1)
              fi
              
              if [[ -n \"\$CLAIM_SCRIPT\" && -f \"\$CLAIM_SCRIPT\" ]]; then
                echo \"Found claim script: \$CLAIM_SCRIPT\"
                sudo \"\$CLAIM_SCRIPT\" -token=\"${{ secrets.NETDATA_CLAIM_TOKEN }}\" \\
                  -rooms=\"${{ secrets.NETDATA_CLAIM_ROOM }}\" \\
                  -url=\"https://app.netdata.cloud\" && \\
                  echo '‚úÖ Netdata reclaim completed' || echo '‚ö†Ô∏è Netdata reclaim failed'
                
                # Restart Netdata after claiming
                sudo systemctl restart netdata
                sleep 5
              else
                echo '‚ö†Ô∏è Netdata claim script not found'
              fi
            fi
          " || echo "‚ö†Ô∏è Failed to check Netdata status"
          
          echo ""
          echo "üìä Netdata URLs:"
          echo "  - Local: http://ats:19999 or http://$TAILSCALE_IP:19999"
          echo "  - Cloud: https://app.netdata.cloud (if claimed successfully)"
