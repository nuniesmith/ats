name: üöÄ ATS Server Complete Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'What to deploy'
        required: true
        type: choice
        options:
          - 'full-deploy'          # Deploy both React web app and ATS server
          - 'web-only'             # Deploy only React web interface
          - 'ats-server-only'      # Deploy only ATS dedicated server
          - 'client-package'       # Create client package for players
          - 'update-mods'          # Update server mods only
          - 'test-deployment'      # Test deployment without creating servers
        default: 'web-only'
      
      create_new_server:
        description: 'Create new Linode server for ATS'
        required: false
        type: boolean
        default: false
      
      server_type:
        description: 'Server type to create'
        required: false
        type: choice
        options:
          - 'g6-standard-2'        # 2GB RAM, 1 CPU (recommended for ATS)
          - 'g6-standard-4'        # 4GB RAM, 2 CPU (for multiple servers)
          - 'g6-standard-8'        # 8GB RAM, 4 CPU (for heavy mod loads)
        default: 'g6-standard-2'
      
      target_region:
        description: 'Linode region for server'
        required: false
        type: choice
        options:
          - 'us-east'              # New York/Newark
          - 'us-central'           # Dallas
          - 'us-west'              # Los Angeles
          - 'ca-central'           # Toronto
          - 'eu-west'              # London
        default: 'ca-central'

env:
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'web-only' }}
  CREATE_NEW_SERVER: ${{ github.event.inputs.create_new_server || 'false' }}
  SERVER_TYPE: ${{ github.event.inputs.server_type || 'g6-standard-2' }}
  TARGET_REGION: ${{ github.event.inputs.target_region || 'ca-central' }}
  DOMAIN_NAME: ats.7gram.xyz
  NODE_VERSION: '18'

jobs:
  # ============================================================================
  # Infrastructure Check & Setup
  # ============================================================================
  infrastructure-check:
    name: üèóÔ∏è Infrastructure Check
    runs-on: self-hosted
    outputs:
      server-exists: ${{ steps.check-server.outputs.exists }}
      server-ip: ${{ steps.check-server.outputs.ip }}
      server-status: ${{ steps.check-server.outputs.status }}
      should-create: ${{ steps.decision.outputs.create }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Check Existing Linode Servers
        id: check-server
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
        run: |
          echo "üîç Checking for existing ATS servers..."
          
          # Install Linode CLI if not present
          if ! command -v linode-cli &> /dev/null; then
            echo "Installing Linode CLI..."
            pip3 install linode-cli
          fi
          
          # Configure Linode CLI
          echo "$LINODE_TOKEN" | linode-cli configure --token
          
          # Check for existing servers
          SERVER_INFO=$(linode-cli linodes list --text --no-headers --format="label,ipv4,status" | grep "ats-server" || true)
          
          if [ -n "$SERVER_INFO" ]; then
            SERVER_IP=$(echo "$SERVER_INFO" | awk '{print $2}' | tr -d '[]')
            SERVER_STATUS=$(echo "$SERVER_INFO" | awk '{print $3}')
            
            echo "‚úÖ Found existing ATS server:"
            echo "   Label: ats-server"
            echo "   Public IP: $SERVER_IP"
            echo "   Status: $SERVER_STATUS"
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "status=$SERVER_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No existing ATS server found"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ip=" >> $GITHUB_OUTPUT
            echo "status=" >> $GITHUB_OUTPUT
          fi

      - name: ü§î Deployment Decision
        id: decision
        run: |
          echo "ü§î Making deployment decisions..."
          
          SERVER_EXISTS="${{ steps.check-server.outputs.exists }}"
          CREATE_NEW="${{ env.CREATE_NEW_SERVER }}"
          
          if [[ "$SERVER_EXISTS" == "true" ]]; then
            echo "‚úÖ Server exists - will use existing server"
            echo "create=false" >> $GITHUB_OUTPUT
          elif [[ "$CREATE_NEW" == "true" ]]; then
            echo "üî® Will create new server"
            echo "create=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No server exists and create_new_server=false"
            echo "create=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Create New Server (if needed)
  # ============================================================================
  create-server:
    name: üî® Create ATS Server
    runs-on: self-hosted
    needs: infrastructure-check
    if: needs.infrastructure-check.outputs.should-create == 'true'
    outputs:
      server-ip: ${{ steps.create.outputs.ip }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üî® Create Linode Server
        id: create
        env:
          LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
          ATS_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
        run: |
          echo "üî® Creating new ATS server..."
          
          # Create the server
          linode-cli linodes create \
            --label "ats-server" \
            --region "${{ env.TARGET_REGION }}" \
            --type "${{ env.SERVER_TYPE }}" \
            --image "linode/arch" \
            --root_pass "$ATS_ROOT_PASSWORD" \
            --authorized_keys "$(cat ~/.ssh/id_rsa.pub)" \
            --text --no-headers --format="ipv4" > server_ip.txt
          
          SERVER_IP=$(cat server_ip.txt | tr -d '[]')
          echo "‚úÖ Server created with IP: $SERVER_IP"
          echo "ip=$SERVER_IP" >> $GITHUB_OUTPUT
          
          # Wait for server to boot
          echo "‚è≥ Waiting for server to boot..."
          sleep 120
          
          # Test SSH connectivity
          for i in {1..10}; do
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no root@$SERVER_IP "echo 'Server ready'"; then
              echo "‚úÖ Server is ready for configuration"
              break
            fi
            echo "‚è≥ Waiting for SSH... (attempt $i/10)"
            sleep 30
          done

      - name: üîß Configure Server
        env:
          SERVER_IP: ${{ steps.create.outputs.ip }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          echo "üîß Configuring new server..."
          
          # Configure server via SSH
          ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOL'
            # Update system
            pacman -Syu --noconfirm
            
            # Install essential packages
            pacman -S --noconfirm nginx nodejs npm git wget curl unzip
            
            # Create actions user
            useradd -m -s /bin/bash actions
            echo "actions:${{ secrets.ACTIONS_USER_PASSWORD }}" | chpasswd
            
            # Add actions to sudoers
            echo "actions ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
            
            # Install Tailscale
            curl -fsSL https://tailscale.com/install.sh | sh
            tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=ats-server
            
            # Create web directory
            mkdir -p /var/www/ats
            chown -R www-data:www-data /var/www/ats || chown -R nginx:nginx /var/www/ats
            
            # Configure Nginx
            cat > /etc/nginx/sites-available/ats << 'NGINX_CONF'
          server {
              listen 80;
              server_name ats.7gram.xyz;
              root /var/www/ats;
              index index.html index.htm;
              
              location / {
                  try_files $uri $uri/ /index.html;
              }
              
              location /api {
                  proxy_pass http://localhost:3001;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
              }
              
              location /socket.io {
                  proxy_pass http://localhost:3001;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
              }
          }
          NGINX_CONF
            
            # Enable site
            ln -sf /etc/nginx/sites-available/ats /etc/nginx/sites-enabled/
            
            # Start services
            systemctl enable nginx
            systemctl start nginx
            systemctl enable tailscaled
            
            echo "‚úÖ Server configuration completed"
          EOL

  # ============================================================================
  # Build Docker Images
  # ============================================================================
  build-docker-images:
    name: üê≥ Build Docker Images
    runs-on: self-hosted
    if: contains(fromJson('["web-only", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üèóÔ∏è Build React Web App Image
        run: |
          echo "üèóÔ∏è Building React web application Docker image..."
          cd web
          docker build -t ats-web:latest .
          docker save ats-web:latest > ../ats-web-image.tar

      - name: üèóÔ∏è Build API Server Image
        run: |
          echo "üèóÔ∏è Building API server Docker image..."
          cd api
          docker build -t ats-api:latest .
          docker save ats-api:latest > ../ats-api-image.tar

      - name: üì§ Upload Docker Images
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            ats-web-image.tar
            ats-api-image.tar
            docker-compose.yml

  # ============================================================================
  # Build React Web Application (fallback)
  # ============================================================================
  build-web-app:
    name: üåê Build React Web Application
    runs-on: self-hosted
    if: contains(fromJson('["web-only", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'web/package-lock.json'

      - name: üì¶ Install dependencies
        working-directory: ./web
        run: npm ci

      - name: üèóÔ∏è Build React application
        working-directory: ./web
        env:
          VITE_API_URL: https://ats.7gram.xyz/api
          VITE_SOCKET_URL: https://ats.7gram.xyz
        run: npm run build

      - name: üì§ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: react-build
          path: web/dist/

  # ============================================================================
  # Create Client Package
  # ============================================================================
  create-client-package:
    name: üì¶ Create Windows Client Package
    runs-on: self-hosted
    if: contains(fromJson('["client-package", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Create Windows Client Package
        run: |
          echo "üì¶ Creating Windows client package..."
          mkdir -p client-package/windows
          
          # Create client connection script
          cat > client-package/windows/Connect_To_ATS_Server.bat << 'EOL'
          @echo off
          title ATS Server Connector - Freddy's Server
          
          echo ==========================================
          echo   ATS Server Connector - Freddy's Server
          echo ==========================================
          echo.
          
          set /p SERVER_ID="Enter Server ID (from Discord): "
          
          if "%SERVER_ID%"=="" (
              echo Error: Server ID is required!
              pause
              exit /b 1
          )
          
          echo.
          echo Connecting to server: %SERVER_ID%
          echo Password: ${{ secrets.ATS_DEFAULT_PASSWORD }}
          echo Domain: ${{ env.DOMAIN_NAME }}
          echo.
          
          start "" "steam://connect/${{ env.DOMAIN_NAME }}:27015/${{ secrets.ATS_DEFAULT_PASSWORD }}"
          
          echo.
          echo ATS should be launching...
          echo If it doesn't work, make sure:
          echo   1. Steam is running
          echo   2. ATS is installed
          echo   3. You're connected to Tailscale VPN
          echo.
          pause
          EOL
          
          # Create desktop shortcut creator
          cat > client-package/windows/Create_Desktop_Shortcut.vbs << 'EOL'
          Set oWS = WScript.CreateObject("WScript.Shell")
          sLinkFile = oWS.SpecialFolders("Desktop") & "\ATS - Freddy's Server.lnk"
          Set oLink = oWS.CreateShortcut(sLinkFile)
          oLink.TargetPath = WScript.ScriptFullName.Replace(WScript.ScriptName, "Connect_To_ATS_Server.bat")
          oLink.WorkingDirectory = WScript.ScriptFullName.Replace("\" & WScript.ScriptName, "")
          oLink.Description = "Connect to Freddy's ATS Server"
          oLink.Save
          WScript.Echo "Desktop shortcut created successfully!"
          EOL
          
          # Create README
          cat > client-package/windows/README.txt << 'EOL'
          ATS Client Package - Freddy's Server
          ===================================
          
          QUICK SETUP:
          1. Install Tailscale VPN from https://tailscale.com/download
          2. Get invited to the Tailscale network (contact Freddy)
          3. Double-click "Create_Desktop_Shortcut.vbs" to create desktop shortcut
          4. Use the desktop shortcut to connect to the server
          
          CONNECTING:
          - Double-click the desktop shortcut "ATS - Freddy's Server"
          - Enter the Server ID when prompted (get this from Discord)
          - Password is: ${{ secrets.ATS_DEFAULT_PASSWORD }}
          
          REQUIREMENTS:
          - Steam with American Truck Simulator
          - Tailscale VPN (for server access)
          - Server ID from Discord
          
          SERVER DETAILS:
          - Name: Freddy's ATS Dedicated Server
          - Domain: ${{ env.DOMAIN_NAME }}
          - Port: 27015
          - Password: ${{ secrets.ATS_DEFAULT_PASSWORD }}
          - Max Players: 8
          - Mods: Collection ID ${{ secrets.STEAM_COLLECTION_ID }}
          EOL
          
          echo "‚úÖ Client package created successfully!"

      - name: üì§ Upload Client Package
        uses: actions/upload-artifact@v4
        with:
          name: windows-client-package
          path: client-package/

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy-to-server:
    name: üöÄ Deploy to ATS Server
    runs-on: self-hosted
    needs: [infrastructure-check, build-web-app, create-server]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["web-only", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only') &&
      needs.build-web-app.result == 'success'
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: react-build
          path: ./web-build

      - name: üåê Setup Tailscale Connection
        run: |
          echo "üåê Connecting to Tailscale network..."
          
          # Install Tailscale if not present
          if ! command -v tailscale &> /dev/null; then
            curl -fsSL https://tailscale.com/install.sh | sh
          fi
          
          # Connect to Tailscale
          sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --accept-routes
          
          # Wait for connection
          sleep 10
          
          # Get server IP (from previous job or existing server)
          SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
          if [ -z "$SERVER_IP" ] && [ "${{ needs.create-server.result }}" == "success" ]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
          fi
          
          echo "SERVER_IP=$SERVER_IP" >> $GITHUB_ENV
          
          # Get Tailscale IP of the server
          TAILSCALE_IP=$(tailscale status | grep "ats-server" | awk '{print $1}' || echo "")
          
          if [ -n "$TAILSCALE_IP" ]; then
            echo "‚úÖ Server Tailscale IP: $TAILSCALE_IP"
            echo "TAILSCALE_IP=$TAILSCALE_IP" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Could not find server Tailscale IP, using public IP"
            echo "TAILSCALE_IP=$SERVER_IP" >> $GITHUB_ENV
          fi

  deploy-docker-to-server:
    name: üöÄ Deploy Docker to ATS Server
    runs-on: self-hosted
    needs: [infrastructure-check, build-docker-images, create-server]
    if: |
      always() && 
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success') &&
      contains(fromJson('["web-only", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only') &&
      needs.build-docker-images.result == 'success'
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ÔøΩ Download Docker Images
        uses: actions/download-artifact@v4
        with:
          name: docker-images
          path: ./docker-artifacts

      - name: üåê Setup Tailscale Connection
        run: |
          echo "üåê Connecting to Tailscale network..."
          
          # Install Tailscale if not present
          if ! command -v tailscale &> /dev/null; then
            curl -fsSL https://tailscale.com/install.sh | sh
          fi
          
          # Connect to Tailscale
          sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --accept-routes
          
          # Wait for connection
          sleep 10
          
          # Get server IP (from previous job or existing server)
          SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
          if [ -z "$SERVER_IP" ] && [ "${{ needs.create-server.result }}" == "success" ]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
          fi
          
          echo "SERVER_IP=$SERVER_IP" >> $GITHUB_ENV
          
          # Get Tailscale IP of the server
          TAILSCALE_IP=$(tailscale status | grep "ats-server" | awk '{print $1}' || echo "")
          
          if [ -n "$TAILSCALE_IP" ]; then
            echo "‚úÖ Server Tailscale IP: $TAILSCALE_IP"
            echo "TAILSCALE_IP=$TAILSCALE_IP" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Could not find server Tailscale IP, using public IP"
            echo "TAILSCALE_IP=$SERVER_IP" >> $GITHUB_ENV
          fi

      - name: üîÑ Update Repository on Server
        env:
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "ÔøΩ Updating repository on server at $SERVER_IP..."
          
          # Update or clone repository on server
          sshpass -p "$ACTIONS_USER_PASSWORD" ssh -o StrictHostKeyChecking=no actions@$SERVER_IP << 'EOL'
            # Check if repository exists
            if [ -d "/home/actions/ats" ]; then
              echo "üì¶ Updating existing repository..."
              cd /home/actions/ats
              git fetch origin
              git reset --hard origin/main
              git clean -fd
            else
              echo "üì• Cloning repository..."
              cd /home/actions
              git clone https://github.com/nuniesmith/ats.git
              cd ats
            fi
            
            echo "‚úÖ Repository updated successfully"
          EOL

      - name: üê≥ Deploy Docker Containers
        env:
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JWT_SECRET: ${{ secrets.ATS_SERVER_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          ATS_DEFAULT_PASSWORD: ${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID: ${{ secrets.STEAM_COLLECTION_ID }}
        run: |
          echo "üê≥ Deploying Docker containers to server at $SERVER_IP..."
          
          # Copy Docker images to server
          echo "üì¶ Uploading Docker images..."
          scp -o StrictHostKeyChecking=no -p "$ACTIONS_USER_PASSWORD" \
            docker-artifacts/ats-web-image.tar \
            docker-artifacts/ats-api-image.tar \
            docker-artifacts/docker-compose.yml \
            actions@$SERVER_IP:/home/actions/ats/
          
          # Deploy containers on server
          echo "ÔøΩ Starting Docker deployment..."
          sshpass -p "$ACTIONS_USER_PASSWORD" ssh -o StrictHostKeyChecking=no actions@$SERVER_IP << 'EOL'
            cd /home/actions/ats
            
            # Load Docker images
            echo "üì• Loading Docker images..."
            sudo docker load < ats-web-image.tar
            sudo docker load < ats-api-image.tar
            
            # Create environment file
            cat > .env << ENV_FILE
          JWT_SECRET=$JWT_SECRET
          CLOUDFLARE_API_TOKEN=$CLOUDFLARE_API_TOKEN
          CLOUDFLARE_ZONE_ID=$CLOUDFLARE_ZONE_ID
          DOMAIN_NAME=ats.7gram.xyz
          DISCORD_WEBHOOK_URL=$DISCORD_WEBHOOK_URL
          ATS_DEFAULT_PASSWORD=$ATS_DEFAULT_PASSWORD
          STEAM_COLLECTION_ID=$STEAM_COLLECTION_ID
          ENV_FILE
            
            # Stop existing containers
            echo "üõë Stopping existing containers..."
            sudo docker-compose down || true
            
            # Start new containers
            echo "üöÄ Starting new containers..."
            sudo docker-compose up -d
            
            # Wait for containers to start
            sleep 30
            
            # Check container health
            echo "üè• Checking container health..."
            sudo docker-compose ps
            
            # Show logs for debugging
            echo "üìã Container logs:"
            sudo docker-compose logs --tail=20
            
            echo "‚úÖ Docker deployment completed"
          EOL

      - name: üåç Update Cloudflare DNS with Tailscale IP
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          if [ -n "$TAILSCALE_IP" ]; then
            echo "üåç Updating Cloudflare DNS record..."
            
            # Get current DNS record
            RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?name=$DOMAIN_NAME&type=A" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" | jq -r '.result[0].id // empty')
            
            if [ -n "$RECORD_ID" ]; then
              # Update existing record with Tailscale IP
              curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"A\",\"name\":\"$DOMAIN_NAME\",\"content\":\"$TAILSCALE_IP\",\"ttl\":300}" \
                | jq '.success'
              
              echo "‚úÖ DNS record updated: $DOMAIN_NAME ‚Üí $TAILSCALE_IP"
            else
              # Create new record with Tailscale IP
              curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"A\",\"name\":\"$DOMAIN_NAME\",\"content\":\"$TAILSCALE_IP\",\"ttl\":300}" \
                | jq '.success'
              
              echo "‚úÖ DNS record created: $DOMAIN_NAME ‚Üí $TAILSCALE_IP"
            fi
          else
            echo "‚ö†Ô∏è No Tailscale IP found, skipping DNS update"
          fi

  # ============================================================================
  # Deploy ATS Server (if requested)
  # ============================================================================
  deploy-ats-server:
    name: üéÆ Deploy ATS Dedicated Server
    runs-on: self-hosted
    needs: [infrastructure-check, deploy-docker-to-server, create-server]
    if: |
      always() && 
      contains(fromJson('["ats-server-only", "full-deploy"]'), github.event.inputs.deployment_mode || 'web-only') &&
      (needs.infrastructure-check.outputs.server-exists == 'true' || needs.create-server.result == 'success')
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üéÆ Install ATS Dedicated Server
        env:
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          ATS_SERVER_TOKEN: ${{ secrets.ATS_SERVER_TOKEN }}
          ATS_DEFAULT_PASSWORD: ${{ secrets.ATS_DEFAULT_PASSWORD }}
          STEAM_COLLECTION_ID: ${{ secrets.STEAM_COLLECTION_ID }}
        run: |
          SERVER_IP="${{ needs.infrastructure-check.outputs.server-ip }}"
          if [ -z "$SERVER_IP" ] && [ "${{ needs.create-server.result }}" == "success" ]; then
            SERVER_IP="${{ needs.create-server.outputs.server-ip }}"
          fi
          
          echo "üéÆ Installing ATS Dedicated Server on $SERVER_IP..."
          
          # Install ATS server via SSH
          sshpass -p "$ACTIONS_USER_PASSWORD" ssh -o StrictHostKeyChecking=no actions@$SERVER_IP << 'EOL'
            # Install SteamCMD
            sudo pacman -S --noconfirm lib32-gcc-libs
            
            # Create steam user
            sudo useradd -m steam
            sudo su - steam -c "
              # Download SteamCMD
              curl -sqL 'https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz' | tar zxvf -
              
              # Install ATS Dedicated Server
              ./steamcmd.sh +force_install_dir ./ats-server +login anonymous +app_update 270880 validate +quit
              
              # Configure server
              mkdir -p ./ats-server/config
              cat > ./ats-server/config/server_config.sii << 'ATS_CONFIG'
          SiiNunit
          {
          server_config : _nameless.1.2.3 {
              name: \"Freddy's ATS Dedicated Server\"
              description: \"Welcome to Freddy's ATS Server! Join our Discord for the latest updates.\"
              password: \"$ATS_DEFAULT_PASSWORD\"
              max_players: 8
              max_vehicles_total: 100
              max_ai_vehicles_player: 50
              max_ai_vehicles_player_spawn: 50
              connection_virtual_port: 100
              query_virtual_port: 101
              server_logon_token: \"$ATS_SERVER_TOKEN\"
              player_file_check: true
              player_file_check_crash: 0
              hide_in_company: false
              force_speed_limiter: false
              force_air_brake_sim: false
              timezones: 1
              service_no_passengers: false
              initial_economy: 1
              disable_autosave: 0
              server_packages: [
                  \"mod_workshop_package.$STEAM_COLLECTION_ID\"
              ]
          }
          }
          ATS_CONFIG
            "
            
            # Create systemd service
            sudo tee /etc/systemd/system/ats-server.service << 'SERVICE'
          [Unit]
          Description=American Truck Simulator Dedicated Server
          After=network.target
          
          [Service]
          Type=simple
          User=steam
          WorkingDirectory=/home/steam/ats-server
          ExecStart=/home/steam/ats-server/bin/linux_x64/eurotrucks2_server
          Restart=always
          RestartSec=10
          
          [Install]
          WantedBy=multi-user.target
          SERVICE
            
            # Enable and start service
            sudo systemctl daemon-reload
            sudo systemctl enable ats-server
            sudo systemctl start ats-server
            
            echo "‚úÖ ATS Dedicated Server installed and started"
          EOL

  # ============================================================================
  # Deployment Summary & Notifications
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: self-hosted
    needs: [infrastructure-check, build-docker-images, create-client-package, deploy-docker-to-server, deploy-ats-server, create-server]
    if: always()
    steps:
      - name: üìä Generate Summary
        run: |
          echo "üìã ATS Deployment Summary"
          echo "========================"
          echo "Deployment Mode: ${{ env.DEPLOYMENT_MODE }}"
          echo "Timestamp: $(date)"
          echo ""
          
          # Infrastructure status
          if [[ "${{ needs.infrastructure-check.outputs.server-exists }}" == "true" ]]; then
            echo "‚úÖ Infrastructure: Used existing server"
            echo "   Server IP: ${{ needs.infrastructure-check.outputs.server-ip }}"
          elif [[ "${{ needs.create-server.result }}" == "success" ]]; then
            echo "‚úÖ Infrastructure: Created new server"
            echo "   Server IP: ${{ needs.create-server.outputs.server-ip }}"
          else
            echo "‚è≠Ô∏è Infrastructure: No server operations"
          fi
          
          # Web app status
          if [[ "${{ needs.build-docker-images.result }}" == "success" ]]; then
            echo "‚úÖ Docker Images: Built successfully"
          elif [[ "${{ needs.build-docker-images.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Docker Images: Skipped"
          else
            echo "‚ùå Docker Images: ${{ needs.build-docker-images.result }}"
          fi
          
          # Client package status
          if [[ "${{ needs.create-client-package.result }}" == "success" ]]; then
            echo "‚úÖ Client Package: Created successfully"
          elif [[ "${{ needs.create-client-package.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Client Package: Skipped"
          else
            echo "‚ùå Client Package: ${{ needs.create-client-package.result }}"
          fi
          
          # Deployment status
          if [[ "${{ needs.deploy-docker-to-server.result }}" == "success" ]]; then
            echo "‚úÖ Docker Deployment: Completed successfully"
          elif [[ "${{ needs.deploy-docker-to-server.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Docker Deployment: Skipped"
          else
            echo "‚ùå Docker Deployment: ${{ needs.deploy-docker-to-server.result }}"
          fi
          
          # ATS server status
          if [[ "${{ needs.deploy-ats-server.result }}" == "success" ]]; then
            echo "‚úÖ ATS Server: Deployed successfully"
          elif [[ "${{ needs.deploy-ats-server.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è ATS Server: Skipped"
          else
            echo "‚ùå ATS Server: ${{ needs.deploy-ats-server.result }}"
          fi
          
          echo ""
          echo "üåê Web Interface: https://${{ env.DOMAIN_NAME }}"
          echo "üîí VPN Required: Tailscale"
          echo "üì¶ Client Package: Available for download"
          echo "üéÆ ATS Server: ${{ env.DOMAIN_NAME }}:27015"
          echo "üîë Server Password: ${{ secrets.ATS_DEFAULT_PASSWORD }}"

      - name: üí¨ Send Discord Notification
        if: env.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          # Determine overall status
          if [[ "${{ needs.deploy-docker-to-server.result }}" == "success" ]] || [[ "${{ needs.deploy-ats-server.result }}" == "success" ]]; then
            STATUS_EMOJI="‚úÖ"
            STATUS_COLOR="3066993"
            STATUS_TITLE="ATS Deployment Successful!"
          else
            STATUS_EMOJI="‚ùå"
            STATUS_COLOR="15158332"
            STATUS_TITLE="ATS Deployment Failed"
          fi
          
          # Send Discord notification
          curl -H "Content-Type: application/json" \
            -X POST \
            -d "{
              \"embeds\": [{
                \"title\": \"$STATUS_TITLE\",
                \"color\": $STATUS_COLOR,
                \"fields\": [
                  {
                    \"name\": \"Deployment Mode\",
                    \"value\": \"\`${{ env.DEPLOYMENT_MODE }}\`\",
                    \"inline\": true
                  },
                  {
                    \"name\": \"Web Interface\",
                    \"value\": \"https://${{ env.DOMAIN_NAME }}\",
                    \"inline\": true
                  },
                  {
                    \"name\": \"ATS Server\",
                    \"value\": \"${{ env.DOMAIN_NAME }}:27015\",
                    \"inline\": true
                  },
                  {
                    \"name\": \"Access Requirements\",
                    \"value\": \"Tailscale VPN connection required\",
                    \"inline\": false
                  },
                  {
                    \"name\": \"Server Password\",
                    \"value\": \"\`${{ secrets.ATS_DEFAULT_PASSWORD }}\`\",
                    \"inline\": true
                  },
                  {
                    \"name\": \"Workshop Collection\",
                    \"value\": \"${{ secrets.STEAM_COLLECTION_ID }}\",
                    \"inline\": true
                  }
                ],
                \"footer\": {
                  \"text\": \"ATS Server Management System\"
                },
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
              }]
            }" \
            "$DISCORD_WEBHOOK_URL"
