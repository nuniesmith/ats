# Example for ATS Repository
# File: .github/workflows/deploy.yml in your ATS repo

name: üöÄ Manage ATS Game Server

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - 'deploy'
          - 'destroy'
          - 'health-check'
          - 'restart'
        default: 'deploy'
      
      deployment_mode:
        description: 'Deployment mode'
        required: false
        type: choice
        options:
          - 'full-deploy'
          - 'update-only'
          - 'restart-only'
          - 'code-only'
        default: 'update-only'
      
      # üéØ Your New Options
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      build_docker_on_changes:
        description: 'Only build Docker if code/Dockerfile changed'
        required: false
        type: boolean
        default: true
      
      overwrite_server:
        description: 'Destroy and recreate Linode server'
        required: false
        type: boolean
        default: true
      
      # Destroy Options (for destroy action)
      destroy_scope:
        description: 'What to destroy (for destroy action)'
        required: false
        type: choice
        options:
          - 'service-only'
          - 'full-server'
          - 'reset-service'
        default: 'service-only'
      
      confirm_destruction:
        description: 'Type "DESTROY" to confirm destruction'
        required: false
        type: string

jobs:
  manage-ats:
    # üëá This calls your unified actions repository
    uses: nuniesmith/actions/.github/workflows/deploy.yml@main
    with:
      service_name: ats
      action_type: ${{ github.event.inputs.action_type || 'deploy' }}
      deployment_mode: ${{ github.event.inputs.deployment_mode || 'update-only' }}
      skip_tests: ${{ github.event.inputs.skip_tests || false }}
      skip_docker_build: ${{ github.event.inputs.skip_docker_build || false }}
      build_docker_on_changes: ${{ github.event.inputs.build_docker_on_changes || true }}
      overwrite_server: ${{ github.event.inputs.overwrite_server || true }}
      destroy_scope: ${{ github.event.inputs.destroy_scope || 'service-only' }}
      confirm_destruction: ${{ github.event.inputs.confirm_destruction || '' }}
      server_type: g6-standard-2  # 4GB RAM for game server
      target_region: ca-central
      domain_suffix: 7gram.xyz
      enable_monitoring: true
      enable_backups: false
    secrets:
      LINODE_TOKEN: ${{ secrets.LINODE_TOKEN }}
      SERVICE_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
      JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
      ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      TAILSCALE_OAUTH_CLIENT_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
      TAILSCALE_OAUTH_SECRET: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
      NETDATA_CLAIM_TOKEN: ${{ secrets.NETDATA_CLAIM_TOKEN }}
      NETDATA_CLAIM_ROOM: ${{ secrets.NETDATA_CLAIM_ROOM }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}

  # ATS-specific post-deployment
  ats-post-deploy:
    name: üéÆ ATS Game Server Setup
    runs-on: ubuntu-latest
    needs: manage-ats
    if: success() && (github.event.inputs.action_type == 'deploy' || github.event.inputs.action_type == '')
    
    steps:
      - name: üì• Checkout ATS Repository
        uses: actions/checkout@v4

      - name: üåê Update Cloudflare DNS Records
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        if: env.CLOUDFLARE_API_TOKEN != '' && env.CLOUDFLARE_ZONE_ID != ''
        run: |
          echo "üåê Updating Cloudflare DNS records for ATS server..."
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq >/dev/null 2>&1
          
          # Get the Tailscale IP from the infrastructure job output
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          if [[ -z "$TAILSCALE_IP" || "$TAILSCALE_IP" == "unknown" || "$TAILSCALE_IP" == "pending" ]]; then
            echo "‚ö†Ô∏è No valid Tailscale IP available: '$TAILSCALE_IP'"
            echo "Skipping DNS update"
            exit 0
          fi
          
          echo "üîó Using Tailscale IP: $TAILSCALE_IP"
          
          # Update A record for ats.7gram.xyz
          echo "üìù Updating A record for ats.7gram.xyz..."
          
          # Get existing record ID first
          RECORD_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records?type=A&name=ats.7gram.xyz" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          
          if ! echo "$RECORD_RESPONSE" | jq . >/dev/null 2>&1; then
            echo "‚ùå Failed to parse Cloudflare API response"
            echo "Response: $RECORD_RESPONSE"
            exit 1
          fi
          
          RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id // empty')
          
          if [[ -n "$RECORD_ID" && "$RECORD_ID" != "null" ]]; then
            echo "üìù Updating existing A record (ID: $RECORD_ID)..."
            UPDATE_RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"A\",
                \"name\": \"ats\",
                \"content\": \"$TAILSCALE_IP\",
                \"ttl\": 300,
                \"comment\": \"ATS Game Server - Updated by GitHub Actions\"
              }")
            
            SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.success // false')
            if [[ "$SUCCESS" == "true" ]]; then
              echo "‚úÖ A record updated successfully"
            else
              echo "‚ùå Failed to update A record"
              echo "Response: $UPDATE_RESPONSE"
            fi
          else
            echo "üìù Creating new A record..."
            CREATE_RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"A\",
                \"name\": \"ats\",
                \"content\": \"$TAILSCALE_IP\",
                \"ttl\": 300,
                \"comment\": \"ATS Game Server - Created by GitHub Actions\"
              }")
            
            SUCCESS=$(echo "$CREATE_RESPONSE" | jq -r '.success // false')
            if [[ "$SUCCESS" == "true" ]]; then
              echo "‚úÖ A record created successfully"
            else
              echo "‚ùå Failed to create A record"
              echo "Response: $CREATE_RESPONSE"
            fi
          fi
          
          echo "‚úÖ DNS update completed - ats.7gram.xyz now points to $TAILSCALE_IP"
          echo "‚è≥ DNS propagation may take a few minutes..."

      - name: üéÆ Configure Game Server
        env:
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üéÆ Configuring ATS game server..."
          
          # Install sshpass for password authentication
          sudo apt-get update && sudo apt-get install -y sshpass >/dev/null 2>&1
          
          # Get the server IP information
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          echo "üîó Server Tailscale IP: $TAILSCALE_IP"
          
          # Try to determine server connection method
          echo "üîç Determining server connection method..."
          
          # Give SSH service time to be ready after Stage 2
          echo "‚è≥ Waiting for SSH service to be ready..."
          sleep 15
          
          # Get server public IP as fallback
          SERVER_IP="${{ needs.manage-ats.outputs.server_ip }}"
          echo "üîó Server Public IP: $SERVER_IP"
          
          # Method 1: Try Tailscale IP directly (most reliable for GitHub Actions)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$TAILSCALE_IP "echo 'Connected via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            echo "‚úÖ Using Tailscale IP: $SERVER_HOST"
          # Method 2: Try public IP directly
          elif [[ -n "$SERVER_IP" && "$SERVER_IP" != "unknown" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$SERVER_IP "echo 'Connected via public IP'" 2>/dev/null; then
            SERVER_HOST="$SERVER_IP"
            echo "‚úÖ Using public IP: $SERVER_HOST"
          # Method 3: Try public domain (after DNS update)
          elif timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@ats.7gram.xyz "echo 'Connected via public domain'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
            echo "‚úÖ Using public domain: $SERVER_HOST"
          # Method 4: Try root user as fallback
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "echo 'Connected as root via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            SERVER_USER="root"
            echo "‚úÖ Using root@Tailscale IP: $SERVER_HOST (will setup ats_user)"
          else
            echo "‚ùå Could not connect to ATS server via any method"
            echo "üîç Tried:"
            echo "  - Tailscale IP: $TAILSCALE_IP"
            echo "  - Public IP: $SERVER_IP"  
            echo "  - Public domain: ats.7gram.xyz"
            echo "  - Root user fallback: root@$TAILSCALE_IP"
            echo "‚ö†Ô∏è Skipping game server configuration"
            exit 0
          fi
          
          # Set default user if not set
          SERVER_USER="${SERVER_USER:-ats_user}"
          echo "üîó Connecting as: $SERVER_USER@$SERVER_HOST"
          
          # If we connected as root, set up ats_user properly
          if [[ "$SERVER_USER" == "root" ]]; then
            echo "üîß Setting up ats_user access..."
            sshpass -e ssh -o StrictHostKeyChecking=no root@$SERVER_HOST "
              # Ensure ats_user exists and has proper setup
              id ats_user || useradd -m -s /bin/bash ats_user
              echo 'ats_user:${{ secrets.ACTIONS_USER_PASSWORD }}' | chpasswd
              usermod -aG docker ats_user
              mkdir -p /home/ats_user/.ssh
              chmod 700 /home/ats_user/.ssh  
              chown ats_user:ats_user /home/ats_user/.ssh
            "
            # Now switch to ats_user for the rest
            SERVER_USER="ats_user"
          fi
          
          echo "üîÑ Waiting for services to be ready..."
          sleep 30
          
          # Clone or update the ATS repository
          echo "ÔøΩ Setting up ATS repository..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            # Ensure git is available and configured
            git --version || { echo 'Git not found'; exit 1; }
            
            # Remove existing directory if it exists and clone fresh
            rm -rf /home/ats_user/ats
            
            # Clone the ATS repository (public repo, no auth needed)
            echo 'Cloning ATS repository from GitHub...'
            git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats || {
              echo 'Failed to clone repository, trying alternative methods...'
              # Try with explicit HTTPS
              git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats --depth 1 || {
                echo 'Git clone failed completely'
                exit 1
              }
            }
            
            # Change ownership to ats_user if we're running as root
            if [[ \$(whoami) == 'root' ]]; then
              chown -R ats_user:ats_user /home/ats_user/ats
            fi
            
            # Change to the repository directory
            cd /home/ats_user/ats
            
            echo 'Repository cloned successfully!'
            echo 'Repository contents:'
            ls -la
            
            echo 'Git repository info:'
            git log --oneline -5 || echo 'Git log unavailable'
          " || {
            echo "‚ö†Ô∏è Failed to clone ATS repository"
            exit 1
          }
          
          # Upload any local configs if they exist (to override defaults)
          if [[ -f "config/server_config.sii" ]]; then
            echo "üìÅ Uploading custom server configuration..."
            sshpass -e scp -o StrictHostKeyChecking=no config/server_config.sii $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload server config"
            }
          fi
          
          if [[ -d "config/" ]]; then
            echo "üìÅ Uploading additional custom configurations..."
            sshpass -e scp -r -o StrictHostKeyChecking=no config/* $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload some configs"
            }
          fi
          
          # Pull Docker images and start services
          echo "üê≥ Starting ATS services from repository..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            cd /home/ats_user/ats || exit 1
            
            echo 'Current directory contents:'
            ls -la
            
            # Fix Docker networking issues first
            echo 'üîß Fixing Docker networking...'
            
            # Stop any existing services and clean up networks
            docker-compose down --remove-orphans 2>/dev/null || true
            docker network prune -f 2>/dev/null || true
            
            # Check for iptables issues and fix them
            echo 'üîç Checking iptables configuration...'
            if ! sudo iptables -t nat -L DOCKER >/dev/null 2>&1; then
              echo '‚ö†Ô∏è Docker iptables chain missing, recreating...'
              
              # Stop Docker
              sudo systemctl stop docker
              
              # Clean up any Docker-related iptables rules
              sudo iptables -t nat -F DOCKER 2>/dev/null || true
              sudo iptables -t filter -F DOCKER 2>/dev/null || true
              sudo iptables -t filter -F DOCKER-ISOLATION-STAGE-1 2>/dev/null || true
              sudo iptables -t filter -F DOCKER-ISOLATION-STAGE-2 2>/dev/null || true
              
              # Remove Docker chains if they exist
              sudo iptables -t nat -X DOCKER 2>/dev/null || true
              sudo iptables -t filter -X DOCKER 2>/dev/null || true
              sudo iptables -t filter -X DOCKER-ISOLATION-STAGE-1 2>/dev/null || true
              sudo iptables -t filter -X DOCKER-ISOLATION-STAGE-2 2>/dev/null || true
              
              # Remove any existing Docker network interfaces
              for interface in \$(ip link show | grep br- | cut -d: -f2 | tr -d ' '); do
                sudo ip link delete \"\$interface\" 2>/dev/null || true
              done
              
              echo '‚úÖ Cleaned up Docker networking components'
            fi
            
            # Restart Docker to clear any iptables issues
            echo 'üîÑ Restarting Docker service to clear network issues...'
            sudo systemctl restart docker
            sleep 10
            
            # Verify Docker is working
            docker info >/dev/null 2>&1 || {
              echo '‚ùå Docker service not ready after restart'
              sudo systemctl status docker
              exit 1
            }
            
            echo '‚úÖ Docker service restarted successfully'
            
            # Pull the latest images
            echo 'Pulling Docker images...'
            docker-compose pull || echo 'Failed to pull some images (may not exist yet)'
            
            # Start the services with network fixes
            echo 'Starting ATS services...'
            docker-compose up -d || {
              echo 'Docker compose failed, trying network reset and retry...'
              
              # Try to reset Docker networks completely
              echo 'üîß Resetting Docker networks...'
              docker network ls -q | xargs -r docker network rm 2>/dev/null || true
              sudo systemctl restart docker
              sleep 10
              
              # Try again with simplified approach
              docker-compose up -d --force-recreate || {
                echo 'Docker compose still failing, trying alternative startup methods...'
                
                # Try different startup methods
                if [[ -f start.sh ]]; then
                  echo 'Found start.sh, running it...'
                  chmod +x start.sh && ./start.sh
                elif [[ -f deploy.sh ]]; then
                  echo 'Found deploy.sh, running it...'
                  chmod +x deploy.sh && ./deploy.sh
                elif [[ -f run.sh ]]; then
                  echo 'Found run.sh, running it...'
                  chmod +x run.sh && ./run.sh
                else
                  echo 'Trying manual Docker run as last resort...'
                  
                  # Check if we have any built images and try to run them manually
                  IMAGES=\$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'ats|web|api' | head -3)
                  if [[ -n \"\$IMAGES\" ]]; then
                    echo 'Found ATS images, trying manual startup:'
                    echo \"\$IMAGES\"
                    
                    # Stop any existing containers with the same names
                    docker stop ats-web ats-api ats-server 2>/dev/null || true
                    docker rm ats-web ats-api ats-server 2>/dev/null || true
                    
                    # Try to run the web interface at least
                    WEB_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'web|nginx' | head -1)
                    if [[ -n \"\$WEB_IMAGE\" ]]; then
                      echo \"Starting web interface: \$WEB_IMAGE\"
                      docker run -d --name ats-web --restart unless-stopped -p 80:80 -p 8080:80 \"\$WEB_IMAGE\" && \\
                        echo '‚úÖ Web interface started successfully' || echo '‚ùå Manual web startup failed'
                    fi
                    
                    # Try to run the API
                    API_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'api|server' | head -1)
                    if [[ -n \"\$API_IMAGE\" ]]; then
                      echo \"Starting API service: \$API_IMAGE\"
                      docker run -d --name ats-api --restart unless-stopped -p 3000:3000 -p 27015:27015 \"\$API_IMAGE\" && \\
                        echo '‚úÖ API service started successfully' || echo '‚ùå Manual API startup failed'
                    fi
                    
                    # Check if we have a game server image
                    SERVER_IMAGE=\$(echo \"\$IMAGES\" | grep -E 'server|game' | head -1)
                    if [[ -n \"\$SERVER_IMAGE\" && \"\$SERVER_IMAGE\" != \"\$API_IMAGE\" ]]; then
                      echo \"Starting game server: \$SERVER_IMAGE\"
                      docker run -d --name ats-server --restart unless-stopped -p 27015:27015/tcp -p 27015:27015/udp \"\$SERVER_IMAGE\" && \\
                        echo '‚úÖ Game server started successfully' || echo '‚ùå Manual game server startup failed'
                    fi
                    
                    # Wait a bit for containers to start
                    sleep 5
                    
                  else
                    echo 'No ATS Docker images found to run manually'
                    echo 'Available images:'
                    docker images
                  fi
                fi
              }
            }
            
            # Show final status
            echo ''
            echo 'üîç Checking Docker services status...'
            
            # Wait for services to fully start
            echo "‚è±Ô∏è Waiting for services to initialize..."
            sleep 15
            
            # Check Docker containers
            echo 'Docker containers status:'
            docker ps -a
            
            # Enhanced service verification
            echo ''
            echo 'Docker compose services status:'
            if command -v docker-compose >/dev/null 2>&1; then
              # Use more robust commands that handle errors better
              SERVICES_UP=\$(docker-compose ps -q 2>/dev/null | wc -l || echo \"0\")
              TOTAL_SERVICES=\$(docker-compose config --services 2>/dev/null | wc -l || echo \"0\")
              
              echo \"üìä Services status: \$SERVICES_UP/\$TOTAL_SERVICES running\"
              
              if [[ \"\$SERVICES_UP\" -gt 0 ]]; then
                echo \"‚úÖ Some Docker services are running\"
                docker-compose ps 2>/dev/null || echo 'Could not get compose status'
                
                # Check logs for any obvious errors
                echo \"üìù Quick log check for errors:\"
                docker-compose logs --tail 20 2>/dev/null | grep -i \"error\\|fail\\|exception\" | head -5 || echo \"No obvious errors in recent logs\"
                
              else
                echo \"‚ùå No Docker services are running\"
                docker-compose ps 2>/dev/null || echo 'Docker compose not responding'
                
                # Check if any ATS containers are running manually
                MANUAL_CONTAINERS=\$(docker ps --filter \"name=ats\" --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
                if [[ \"\$MANUAL_CONTAINERS\" -gt 0 ]]; then
                  echo \"üìã Found \$MANUAL_CONTAINERS manually started ATS containers:\"
                  docker ps --filter \"name=ats\" --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
                fi
              fi
            else
              echo 'Docker compose command not available, checking containers directly'
              
              # Check for any running containers
              RUNNING_CONTAINERS=\$(docker ps --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
              if [[ \"\$RUNNING_CONTAINERS\" -gt 0 ]]; then
                echo \"üìã Found \$RUNNING_CONTAINERS running containers:\"
                docker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
              else
                echo \"‚ùå No containers running\"
              fi
            fi
            
            # Show recent logs
            echo ''
            echo 'Recent container logs:'
            docker-compose logs --tail=10 2>/dev/null || docker logs $(docker ps -q | head -1) 2>/dev/null || echo 'Logs unavailable'
          " || {
            echo "‚ö†Ô∏è Failed to start ATS services"
          }

      - name: üß™ Test Game Server
        run: |
          echo "üß™ Testing ATS game server..."
          
          # Wait a bit for services to start and DNS to propagate
          echo "‚è≥ Waiting for services to start and DNS to propagate..."
          sleep 30
          
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          # Test web interface via multiple methods
          echo "üåê Testing web interface..."
          
          # Method 1: Test via Tailscale IP (most likely to work)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 80)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 8080)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -s http://$TAILSCALE_IP | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via Tailscale IP (contains expected content)"
          # Method 2: Test via public domain
          elif timeout 10 curl -f http://ats.7gram.xyz 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 80)"
          elif timeout 10 curl -f http://ats.7gram.xyz:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 8080)"
          elif timeout 10 curl -s http://ats.7gram.xyz | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via public domain (contains expected content)"
          else
            echo "‚ö†Ô∏è ATS web interface not responding via any method"
            echo "üîç Let's check what's actually running on the server..."
            
            # Get more detailed info about what's running
            if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
              echo "üìä Port scan results:"
              timeout 5 nmap -p 80,8080,27015,19999 $TAILSCALE_IP 2>/dev/null || echo "nmap not available"
              
              # Try to get a raw response
              echo "üìù Raw HTTP response:"
              timeout 5 curl -s http://$TAILSCALE_IP | head -10 || echo "No HTTP response"
            fi
          fi
          
          # Test game server port if accessible
          echo "üéÆ Testing game server port..."
          
          if timeout 5 bash -c "</dev/tcp/ats/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale hostname"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 5 bash -c "</dev/tcp/$TAILSCALE_IP/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale IP"
          elif timeout 5 bash -c "</dev/tcp/ats.7gram.xyz/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via public domain"
          else
            echo "‚ÑπÔ∏è Game server port not accessible externally (may be behind firewall or still starting)"
            echo "   This is normal if the game server only accepts connections from Tailscale network"
          fi
          
          echo "üéÆ ATS game server setup complete!"
          echo "üìä Access URLs:"
          echo "  - Tailscale: http://ats:8080 or http://$TAILSCALE_IP:8080"
          echo "  - Public: https://ats.7gram.xyz (after DNS propagation)"
          
          # Final deployment verification
          echo ""
          echo "üéØ Final Deployment Verification:"
          echo "================================"
          
          # Summary of what was accomplished
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
            echo "‚úÖ Server connected to Tailscale: $TAILSCALE_IP"
          else
            echo "‚ö†Ô∏è Tailscale connection status unclear"
          fi
          
          # Check if DNS was updated by verifying if we successfully updated it in the previous step
          if [[ "${{ secrets.CLOUDFLARE_API_TOKEN }}" != "" && "${{ secrets.CLOUDFLARE_ZONE_ID }}" != "" ]]; then
            echo "‚úÖ DNS record updated for ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è DNS update skipped (missing Cloudflare credentials)"
          fi
          
          # Check repository status
          sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "
            if [[ -d '/home/ats_user/ats/.git' ]]; then
              echo '‚úÖ ATS repository cloned successfully'
              cd /home/ats_user/ats && git log --oneline -1 | sed 's/^/    Latest commit: /'
            else
              echo '‚ö†Ô∏è ATS repository not found'
            fi
            
            RUNNING_CONTAINERS=\$(docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -v 'NAMES' | wc -l)
            if [ \"\$RUNNING_CONTAINERS\" -gt 0 ]; then
              echo '‚úÖ Docker services running: '\$RUNNING_CONTAINERS' containers active'
            else
              echo '‚ùå No Docker containers running'
            fi
          " 2>/dev/null || echo "‚ö†Ô∏è Could not verify repository and container status"
          
          echo ""
          echo "üåê Access Information:"
          echo "====================="
          echo "üîó Direct access: http://$TAILSCALE_IP"
          echo "üîó Direct access (alt port): http://$TAILSCALE_IP:8080"
          echo "üîó Public access: http://ats.7gram.xyz"
          echo "üîó Public access (alt port): http://ats.7gram.xyz:8080"
          echo ""
          echo "üìù Note: Services may take a few minutes to fully initialize"
          echo "üéÆ ATS game server should be accessible for multiplayer connections"

      - name: üìä Verify Netdata Cloud Connection
        env:
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üìä Verifying Netdata cloud connection..."
          
          TAILSCALE_IP="${{ needs.manage-ats.outputs.tailscale_ip }}"
          
          # Determine server connection method (same as before)
          if timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@$TAILSCALE_IP "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
          elif timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats.7gram.xyz "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è Cannot connect to check Netdata status"
            exit 0
          fi
          
          echo "üîç Checking Netdata status on $SERVER_HOST..."
          
          # Check if Netdata is running and accessible
          sshpass -e ssh -o StrictHostKeyChecking=no ats_user@$SERVER_HOST "
            echo 'üìä Netdata service status:'
            sudo systemctl is-active netdata && echo '‚úÖ Netdata service is active' || echo '‚ö†Ô∏è Netdata service is not active'
            
            echo ''
            echo 'üåê Testing Netdata web interface:'
            if curl -f http://localhost:19999/api/v1/info 2>/dev/null >/dev/null; then
              echo '‚úÖ Netdata web interface is accessible'
            else
              echo '‚ö†Ô∏è Netdata web interface is not accessible'
            fi
            
            echo ''
            echo '‚òÅÔ∏è Checking Netdata cloud connection:'
            if [[ -f /var/lib/netdata/cloud.d/token ]]; then
              echo '‚úÖ Netdata cloud token file exists'
            else
              echo '‚ö†Ô∏è Netdata cloud token file not found'
            fi
            
            # Check if claiming is successful
            if [[ -f /var/lib/netdata/registry/netdata.public.unique.id ]]; then
              echo '‚úÖ Netdata unique ID exists'
              NETDATA_ID=\$(cat /var/lib/netdata/registry/netdata.public.unique.id 2>/dev/null || echo 'unknown')
              echo 'Netdata ID: '\$NETDATA_ID
            else
              echo '‚ö†Ô∏è Netdata unique ID not found'
            fi
            
            # Try to reclaim if needed
            if [[ ! -f /var/lib/netdata/cloud.d/token ]]; then
              echo ''
              echo 'üîÑ Attempting to reclaim Netdata to cloud...'
              
              # Find the claim script
              CLAIM_SCRIPT=''
              for script_path in \"/usr/sbin/netdata-claim.sh\" \"/opt/netdata/bin/netdata-claim.sh\" \"/usr/libexec/netdata/netdata-claim.sh\" \"/usr/lib/netdata/netdata-claim.sh\"; do
                if [[ -f \"\$script_path\" ]]; then
                  CLAIM_SCRIPT=\$script_path
                  break
                fi
              done
              
              if [[ -z \"\$CLAIM_SCRIPT\" ]]; then
                CLAIM_SCRIPT=\$(find /usr /opt -name \"netdata-claim.sh\" 2>/dev/null | head -1)
              fi
              
              if [[ -n \"\$CLAIM_SCRIPT\" && -f \"\$CLAIM_SCRIPT\" ]]; then
                echo \"Found claim script: \$CLAIM_SCRIPT\"
                sudo \"\$CLAIM_SCRIPT\" -token=\"${{ secrets.NETDATA_CLAIM_TOKEN }}\" \\
                  -rooms=\"${{ secrets.NETDATA_CLAIM_ROOM }}\" \\
                  -url=\"https://app.netdata.cloud\" && \\
                  echo '‚úÖ Netdata reclaim completed' || echo '‚ö†Ô∏è Netdata reclaim failed'
                
                # Restart Netdata after claiming
                sudo systemctl restart netdata
                sleep 5
              else
                echo '‚ö†Ô∏è Netdata claim script not found'
              fi
            fi
          " || echo "‚ö†Ô∏è Failed to check Netdata status"
          
          echo ""
          echo "üìä Netdata URLs:"
          echo "  - Local: http://ats:19999 or http://$TAILSCALE_IP:19999"
          echo "  - Cloud: https://app.netdata.cloud (if claimed successfully)"
