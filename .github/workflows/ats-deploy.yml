# ATS Game Server Deployment using Shared Deploy Workflow
name: üöÄ Deploy ATS Game Server

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - 'deploy'
          - 'destroy'
          - 'health-check'
          - 'restart'
        default: 'deploy'
      
      target_region:
        description: 'Linode region'
        required: false
        type: choice
        options:
          - 'ca-central'
          - 'us-east'
          - 'us-west'
          - 'eu-west'
        default: 'ca-central'
      
      server_type:
        description: 'Linode server type'
        required: false
        type: choice
        options:
          - 'g6-nanode-1'          # 1GB RAM - $5/month (sufficient for lightweight game server)
          - 'g6-standard-1'        # 2GB RAM - $12/month
          - 'g6-standard-2'        # 4GB RAM - $20/month
          - 'g6-standard-4'        # 8GB RAM - $40/month
        default: 'g6-nanode-1'
      
      cleanup_old_resources:
        description: 'Clean up old servers before deployment'
        required: false
        type: boolean
        default: true  # Enable cleanup by default during development
      
      enable_monitoring:
        description: 'Enable Netdata monitoring'
        required: false
        type: boolean
        default: true
      
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      confirm_destruction:
        description: 'Type "DESTROY" to confirm destruction'
        required: false
        type: string

jobs:
  # Pre-deployment cleanup for development
  cleanup-old-resources:
    name: üßπ Cleanup Old Resources
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || inputs.cleanup_old_resources == true
    steps:
      - name: üßπ Cleanup Tailscale and Linode Resources
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          echo "üßπ Cleaning up old ATS resources..."
          
          # Install dependencies
          sudo apt-get update && sudo apt-get install -y curl jq
          
          # Cleanup Tailscale devices first
          if [[ -n "$TAILSCALE_AUTH_KEY" ]]; then
            echo "üîó Cleaning up old Tailscale devices..."
            
            # Get the tailnet name
            TAILNET="${{ secrets.TAILSCALE_TAILNET }}"
            if [[ -z "$TAILNET" ]]; then
              echo "‚ö†Ô∏è TAILSCALE_TAILNET secret not set, using default API endpoint"
              DEVICES_URL="https://api.tailscale.com/api/v2/devices"
            else
              echo "üîç Using tailnet: $TAILNET"
              DEVICES_URL="https://api.tailscale.com/api/v2/tailnet/$TAILNET/devices"
            fi
            
            echo "üåê Fetching devices from: $DEVICES_URL"
            DEVICES_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -H "Authorization: Bearer $TAILSCALE_AUTH_KEY" "$DEVICES_URL" 2>/dev/null || echo "CURL_FAILED")
            
            # Extract HTTP status code
            HTTP_CODE=$(echo "$DEVICES_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            DEVICES_JSON=$(echo "$DEVICES_RESPONSE" | sed '/HTTP_CODE:/d')
            
            echo "üîç API Response Code: $HTTP_CODE"
            
            # Check if we got a valid response with devices
            if [[ "$HTTP_CODE" == "200" ]] && echo "$DEVICES_JSON" | jq -e '.devices' >/dev/null 2>&1; then
              # Find ATS devices (including numbered variants like ats-1, ats-2, etc.)
              DEVICES=$(echo "$DEVICES_JSON" | jq -r '.devices[]? | select((.hostname // .name) | test("^ats(-[0-9]+)?$"; "i")) | .id // empty' | grep -v '^$' | head -10)
              
              if [[ -n "$DEVICES" ]]; then
                echo "Found ATS devices to remove..."
                REMOVED_COUNT=0
                for device_id in $DEVICES; do
                  if [[ -n "$device_id" ]]; then
                    # Get device info
                    DEVICE_INFO=$(echo "$DEVICES_JSON" | jq -r --arg id "$device_id" '.devices[]? | select(.id == $id) | "\(.hostname // .name // "unknown") (\(.addresses[0] // "no-ip"))"')
                    echo "üóëÔ∏è Removing old Tailscale device: $device_id - $DEVICE_INFO"
                    
                    DELETE_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X DELETE \
                      -H "Authorization: Bearer $TAILSCALE_AUTH_KEY" \
                      "https://api.tailscale.com/api/v2/device/$device_id" 2>/dev/null || echo "CURL_FAILED")
                    
                    DELETE_CODE=$(echo "$DELETE_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
                    
                    if [[ "$DELETE_CODE" == "200" || "$DELETE_CODE" == "204" ]]; then
                      echo "   ‚úÖ Successfully removed"
                      ((REMOVED_COUNT++))
                    else
                      echo "   ‚ùå Failed to remove device $device_id (HTTP: $DELETE_CODE)"
                    fi
                    
                    # Rate limiting
                    sleep 1
                  fi
                done
                echo "‚úÖ Removed $REMOVED_COUNT ATS devices"
              else
                echo "‚ÑπÔ∏è No ATS devices found to remove"
              fi
            elif [[ "$HTTP_CODE" == "401" ]]; then
              echo "‚ùå Tailscale API authentication failed - check TAILSCALE_AUTH_KEY"
            elif [[ "$HTTP_CODE" == "403" ]]; then
              echo "‚ùå Tailscale API access forbidden - check API key permissions"
            elif [[ "$HTTP_CODE" == "404" ]]; then
              echo "‚ùå Tailscale tailnet not found - check TAILSCALE_TAILNET value"
            else
              echo "‚ö†Ô∏è Tailscale API error - HTTP: $HTTP_CODE"
              echo "Response: $DEVICES_JSON" | head -100
            fi
          else
            echo "‚ö†Ô∏è Tailscale API token not available"
          fi
          
          # Cleanup Linode servers
          if [[ -n "$LINODE_CLI_TOKEN" ]]; then
            echo "üñ•Ô∏è Cleaning up old Linode servers..."
            
            # Install linode-cli
            pip install linode-cli
            
            # Configure linode-cli
            echo "[DEFAULT]
          token = $LINODE_CLI_TOKEN" > ~/.linode-cli
            
            # Remove old ATS servers
            echo "üîç Looking for old ATS servers..."
            
            OLD_SERVERS=$(linode-cli linodes list --json | jq -r '.[] | select(.label | startswith("ats")) | .id')
            
            for server_id in $OLD_SERVERS; do
              if [[ -n "$server_id" ]]; then
                echo "üóëÔ∏è Removing old Linode server: $server_id (ats)"
                linode-cli linodes delete "$server_id" --json || echo "Failed to remove server $server_id"
                # Wait a bit between deletions
                sleep 5
              fi
            done
          else
            echo "‚ö†Ô∏è Linode CLI token not available"
          fi
          
          echo "‚úÖ Cleanup completed"

  # ATS Game Server Deployment
  deploy-ats:
    name: üéÆ Deploy ATS Game Server
    needs: cleanup-old-resources
    if: always() && (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped')
    uses: nuniesmith/actions/.github/workflows/deploy.yml@main
    with:
      service_name: 'ats'
      action_type: ${{ inputs.action_type || 'deploy' }}
      deployment_mode: 'full-deploy'
      skip_tests: ${{ inputs.skip_tests || false }}
      skip_docker_build: ${{ inputs.skip_docker_build || false }}
      build_docker_on_changes: true
      overwrite_server: true  # Always cleanup during development
      server_type: ${{ inputs.server_type || 'g6-nanode-1' }}  # $5/month basic server - perfect for 2-user game server
      target_region: ${{ inputs.target_region || 'ca-central' }}
      domain_suffix: '7gram.xyz'
      enable_monitoring: ${{ inputs.enable_monitoring || true }}
      enable_backups: false
      destroy_scope: 'full-server'
      confirm_destruction: ${{ inputs.confirm_destruction || '' }}
    secrets:
      LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
      SERVICE_ROOT_PASSWORD: ${{ secrets.ATS_ROOT_PASSWORD }}
      JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
      ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      NETDATA_CLAIM_TOKEN: ${{ secrets.NETDATA_CLAIM_TOKEN }}
      NETDATA_CLAIM_ROOM: ${{ secrets.NETDATA_CLAIM_ROOM }}

  # Post-deployment game server configuration
  ats-configuration:
    name: üéÆ ATS Game Server Configuration
    runs-on: ubuntu-latest
    needs: deploy-ats
    if: always() && needs.deploy-ats.result == 'success'
    
    steps:
      - name: üì• Checkout ATS Repository
        uses: actions/checkout@v4

      - name: üìä Display Deployment Summary
        env:
          SERVER_IP: ${{ needs.deploy-ats.outputs.server_ip }}
          SERVER_ID: ${{ needs.deploy-ats.outputs.server_id }}
        run: |
          echo "üöÄ ATS Game Server Deployment Complete!"
          echo "========================================"
          echo ""
          echo "üéÆ **ATS Game Server:**"
          echo "  ‚Ä¢ Server ID: $SERVER_ID"
          echo "  ‚Ä¢ Server IP: $SERVER_IP"
          echo "  ‚Ä¢ Server Type: ${{ inputs.server_type || 'g6-nanode-1' }} (1GB RAM)"
          echo "  ‚Ä¢ Cost: \$5/month (reduced from \$40/month for lightweight 2-user game server)"
          echo "  ‚Ä¢ Region: ${{ inputs.target_region || 'ca-central' }}"
          echo ""
          echo "üîó **Access URLs:**"
          echo "  ‚Ä¢ Tailscale: http://ats or http://$SERVER_IP"
          echo "  ‚Ä¢ Public HTTP: http://ats.7gram.xyz"
          echo "  ‚Ä¢ Public HTTPS: https://ats.7gram.xyz"
          echo "  ‚Ä¢ Game Server: ats.7gram.xyz:27015"
          echo ""
          echo "üì° **Monitoring:**"
          echo "  ‚Ä¢ Netdata: http://$SERVER_IP:19999"
          echo "  ‚Ä¢ Container Stats: Available via Netdata dashboard"
          echo ""
          echo "üéÆ **Game Server Info:**"
          echo "  ‚Ä¢ Port: 27015 (TCP/UDP)"
          echo "  ‚Ä¢ Max Players: 8 (configurable)"
          echo "  ‚Ä¢ Game Mode: American Truck Simulator Multiplayer"
          echo ""
          echo "üîß **Next Steps:**"
          echo "  1. Services are automatically starting up"
          echo "  2. Game server will be available in a few minutes"
          echo "  3. Connect using: ats.7gram.xyz:27015"
          echo "  4. Monitor performance via Netdata dashboard"
          echo ""
          echo "‚úÖ **ATS game server deployment using shared workflow complete!**"

      - name: üîó Setup Tailscale for Post-Deploy Access
        env:
          TAILSCALE_AUTHKEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        if: env.TAILSCALE_AUTHKEY != ''
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TAILSCALE_AUTH_KEY }}
        continue-on-error: true

      - name: üß™ Test ATS Game Server
        env:
          SERVER_IP: ${{ needs.deploy-ats.outputs.server_ip }}
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üß™ Testing ATS game server..."
          
          # Install sshpass for password authentication
          sudo apt-get update && sudo apt-get install -y sshpass >/dev/null 2>&1
          
          # Get the server IP information
          # Get the Tailscale IP from the infrastructure job output
          TAILSCALE_IP="${{ needs.deploy-ats.outputs.tailscale_ip }}"
          echo "üîó Server Tailscale IP: $TAILSCALE_IP"
          
          # Try to determine server connection method
          echo "üîç Determining server connection method..."
          
          # Give SSH service time to be ready after Stage 2
          echo "‚è≥ Waiting for SSH service to be ready..."
          sleep 15
          
          # Get server public IP as fallback
          SERVER_IP="${{ needs.deploy-ats.outputs.server_ip }}"
          echo "üîó Server Public IP: $SERVER_IP"
          
          # Method 1: Try Tailscale IP directly (most reliable for GitHub Actions)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$TAILSCALE_IP "echo 'Connected via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            echo "‚úÖ Using Tailscale IP: $SERVER_HOST"
          # Method 2: Try public IP directly
          elif [[ -n "$SERVER_IP" && "$SERVER_IP" != "unknown" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@$SERVER_IP "echo 'Connected via public IP'" 2>/dev/null; then
            SERVER_HOST="$SERVER_IP"
            echo "‚úÖ Using public IP: $SERVER_HOST"
          # Method 3: Try public domain (after DNS update)
          elif timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ats_user@ats.7gram.xyz "echo 'Connected via public domain'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
            echo "‚úÖ Using public domain: $SERVER_HOST"
          # Method 4: Try root user as fallback
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 15 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "echo 'Connected as root via Tailscale IP'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
            SERVER_USER="root"
            echo "‚úÖ Using root@Tailscale IP: $SERVER_HOST (will setup ats_user)"
          else
            echo "‚ùå Could not connect to ATS server via any method"
            echo "üîç Tried:"
            echo "  - Tailscale IP: $TAILSCALE_IP"
            echo "  - Public IP: $SERVER_IP"  
            echo "  - Public domain: ats.7gram.xyz"
            echo "  - Root user fallback: root@$TAILSCALE_IP"
            echo "‚ö†Ô∏è Skipping game server configuration"
            exit 0
          fi
          
          # Set default user if not set
          SERVER_USER="${SERVER_USER:-ats_user}"
          echo "üîó Connecting as: $SERVER_USER@$SERVER_HOST"
          
          # If we connected as root, set up ats_user properly
          if [[ "$SERVER_USER" == "root" ]]; then
            echo "üîß Setting up ats_user access..."
            sshpass -e ssh -o StrictHostKeyChecking=no root@$SERVER_HOST "
              # Ensure ats_user exists and has proper setup
              id ats_user || useradd -m -s /bin/bash ats_user
              echo 'ats_user:${{ secrets.ACTIONS_USER_PASSWORD }}' | chpasswd
              usermod -aG docker ats_user
              mkdir -p /home/ats_user/.ssh
              chmod 700 /home/ats_user/.ssh  
              chown ats_user:ats_user /home/ats_user/.ssh
            "
            # Now switch to ats_user for the rest
            SERVER_USER="ats_user"
          fi
          
          echo "üîÑ Waiting for services to be ready..."
          sleep 30
          
          # Clone or update the ATS repository
          echo "ÔøΩ Setting up ATS repository..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            # Ensure git is available and configured
            git --version || { echo 'Git not found'; exit 1; }
            
            # Remove existing directory if it exists and clone fresh
            rm -rf /home/ats_user/ats
            
            # Clone the ATS repository (public repo, no auth needed)
            echo 'Cloning ATS repository from GitHub...'
            git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats || {
              echo 'Failed to clone repository, trying alternative methods...'
              # Try with explicit HTTPS
              git clone https://github.com/nuniesmith/ats.git /home/ats_user/ats --depth 1 || {
                echo 'Git clone failed completely'
                exit 1
              }
            }
            
            # Change ownership to ats_user if we're running as root
            if [[ \$(whoami) == 'root' ]]; then
              chown -R ats_user:ats_user /home/ats_user/ats
            fi
            
            # Change to the repository directory
            cd /home/ats_user/ats
            
            echo 'Repository cloned successfully!'
            echo 'Repository contents:'
            ls -la
            
            echo 'Git repository info:'
            git log --oneline -5 || echo 'Git log unavailable'
          " || {
            echo "‚ö†Ô∏è Failed to clone ATS repository"
            exit 1
          }
          
          # Upload any local configs if they exist (to override defaults)
          if [[ -f "config/server_config.sii" ]]; then
            echo "üìÅ Uploading custom server configuration..."
            sshpass -e scp -o StrictHostKeyChecking=no config/server_config.sii $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload server config"
            }
          fi
          
          if [[ -d "config/" ]]; then
            echo "üìÅ Uploading additional custom configurations..."
            sshpass -e scp -r -o StrictHostKeyChecking=no config/* $SERVER_USER@$SERVER_HOST:/home/ats_user/ats/config/ || {
              echo "‚ö†Ô∏è Failed to upload some configs"
            }
          fi
          
          # Upload and run Docker Compose deployment script
          echo "üê≥ Starting ATS services with Docker Compose..."
          sshpass -e ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            cd /home/ats_user/ats || exit 1
            
            # Make deployment script executable
            chmod +x deploy-compose.sh
            
            # Run deployment with secrets passed as arguments
            ./deploy-compose.sh \\
              '${{ secrets.ATS_ROOT_PASSWORD }}' \\
              '${{ secrets.CLOUDFLARE_API_TOKEN }}' \\
              '${{ secrets.CLOUDFLARE_ZONE_ID }}' \\
              '${{ secrets.DISCORD_WEBHOOK_URL }}' \\
              '${{ secrets.NETDATA_CLAIM_TOKEN }}' \\
              '${{ secrets.NETDATA_CLAIM_ROOM }}'
          " || {
            echo "‚ö†Ô∏è Failed to start ATS services"
          }
            
            # Show final status
            echo ''
            echo 'üîç Checking Docker services status...'
            
            # Wait for services to fully start
            echo "‚è±Ô∏è Waiting for services to initialize..."
            sleep 15
            
            # ===================================
            # COMPREHENSIVE SERVICE VERIFICATION
            # ===================================
            
            echo ''
            echo 'üìä === SERVICE VERIFICATION REPORT ==='
            
            # Check running containers
            echo 'üìã Running containers:'
            CONTAINERS=\$(docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}')
            if [[ -n \"\$CONTAINERS\" ]]; then
              echo \"\$CONTAINERS\"
            else
              echo '‚ùå No containers running'
            fi
            echo ''
            
            # Port connectivity tests
            echo 'üîå Port connectivity tests:'
            PORTS=(80 443 8080 3000 3001 27015)
            for PORT in \"\${PORTS[@]}\"; do
              if netstat -tlnp 2>/dev/null | grep -q \":$PORT \"; then
                echo \"‚úÖ Port \$PORT: LISTENING\"
              else
                echo \"‚ùå Port \$PORT: NOT LISTENING\"
              fi
            done
            echo ''
            
            # Service health checks
            echo 'üè• Service health checks:'
            
            # Web interface tests
            if curl -s --max-time 10 \"http://localhost\" >/dev/null 2>&1; then
              echo '‚úÖ Web interface (port 80): HEALTHY'
              WEB_TITLE=\$(curl -s --max-time 5 \"http://localhost\" | grep -oP '<title>\\K[^<]+' | head -1)
              [[ -n \"\$WEB_TITLE\" ]] && echo \"   üìÑ Page title: \$WEB_TITLE\"
            elif curl -s --max-time 10 \"http://localhost:8080\" >/dev/null 2>&1; then
              echo '‚úÖ Web interface (port 8080): HEALTHY'
            else
              echo '‚ùå Web interface: NOT RESPONDING'
            fi
            
            # API health checks
            if curl -s --max-time 10 \"http://localhost:3000/health\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3000): HEALTHY'
            elif curl -s --max-time 10 \"http://localhost:3001/health\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3001): HEALTHY'
            elif curl -s --max-time 10 \"http://localhost:3000\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3000): RESPONDING'
            elif curl -s --max-time 10 \"http://localhost:3001\" >/dev/null 2>&1; then
              echo '‚úÖ API service (port 3001): RESPONDING'
            else
              echo '‚ùå API service: NOT RESPONDING'
            fi
            
            # Game server connectivity
            if netstat -tlnp 2>/dev/null | grep -q ':27015 '; then
              echo '‚úÖ Game server (port 27015): LISTENING'
              # Test UDP port if possible
              if netstat -ulnp 2>/dev/null | grep -q ':27015 '; then
                echo '‚úÖ Game server UDP (port 27015): LISTENING'
              fi
            else
              echo '‚ùå Game server (port 27015): NOT LISTENING'
            fi
            echo ''
            
            # Resource usage monitoring
            echo 'üìà Resource usage:'
            echo \"üíæ Memory: \$(free -h | grep '^Mem' | awk '{print \$3\"/\"\$2}')\"
            echo \"üíø Disk: \$(df -h / | tail -1 | awk '{print \$3\"/\"\$2\" (\"\$5\" used)\"}')\"
            echo \"üîÑ Load: \$(uptime | awk -F'load average:' '{print \$2}' | xargs)\"
            echo ''
            
            # Docker system info
            echo 'üê≥ Docker system status:'
            echo \"üì¶ Containers: \$(docker ps -q | wc -l) running, \$(docker ps -aq | wc -l) total\"
            echo \"üñºÔ∏è  Images: \$(docker images -q | wc -l) total\"
            echo \"üåê Networks: \$(docker network ls -q | wc -l) total\"
            echo \"üíæ Volumes: \$(docker volume ls -q | wc -l) total\"
            echo ''
            
            # Docker Compose service verification
            echo 'üêô Docker Compose services:'
            
            # Determine which Docker Compose command to use
            COMPOSE_CMD=\"\"
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker compose\"
              echo \"Using Docker Compose V2: docker compose\"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD=\"docker-compose\"
              echo \"Using Docker Compose V1: docker-compose\"
            else
              echo \"‚ùå No Docker Compose command available\"
            fi
            
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              # Use more robust commands that handle errors better
              SERVICES_UP=\$(\$COMPOSE_CMD ps -q 2>/dev/null | wc -l || echo \"0\")
              TOTAL_SERVICES=\$(\$COMPOSE_CMD config --services 2>/dev/null | wc -l || echo \"0\")
              
              echo \"üìä Services status: \$SERVICES_UP/\$TOTAL_SERVICES running\"
              
              if [[ \"\$SERVICES_UP\" -gt 0 ]]; then
                echo \"‚úÖ Some Docker services are running\"
                \$COMPOSE_CMD ps 2>/dev/null || echo 'Could not get compose status'
                
                # Check logs for any obvious errors
                echo \"üìù Quick log check for errors:\"
                \$COMPOSE_CMD logs --tail 20 2>/dev/null | grep -i \"error\\|fail\\|exception\" | head -5 || echo \"No obvious errors in recent logs\"
                
              else
                echo \"‚ùå No Docker Compose services are running\"
                \$COMPOSE_CMD ps 2>/dev/null || echo 'Docker compose not responding'
                
                # Check if any ATS containers are running manually
                MANUAL_CONTAINERS=\$(docker ps --filter \"name=ats\" --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
                if [[ \"\$MANUAL_CONTAINERS\" -gt 0 ]]; then
                  echo \"üìã Found \$MANUAL_CONTAINERS manually started ATS containers:\"
                  docker ps --filter \"name=ats\" --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
                fi
              fi
            else
              echo 'Docker compose command not available, checking containers directly'
              
              # Check for any running containers
              RUNNING_CONTAINERS=\$(docker ps --format \"{{.Names}}\" 2>/dev/null | wc -l || echo \"0\")
              if [[ \"\$RUNNING_CONTAINERS\" -gt 0 ]]; then
                echo \"üìã Found \$RUNNING_CONTAINERS running containers:\"
                docker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || true
              else
                echo \"‚ùå No containers running\"
              fi
            fi
            echo ''
            
            # Service accessibility summary
            echo 'üåç Service accessibility:'
            
            # Test different access methods
            echo 'üîó Access URLs to test:'
            
            # Get server IPs
            TAILSCALE_IP=\$(hostname -I | awk '{print \$1}' | head -1)
            PUBLIC_IP=\$(curl -s --max-time 10 ifconfig.me 2>/dev/null || curl -s --max-time 10 icanhazip.com 2>/dev/null || echo 'unavailable')
            
            if [[ -n \"\$TAILSCALE_IP\" && \"\$TAILSCALE_IP\" != \"127.0.0.1\" ]]; then
              echo \"   üìç Tailscale IP: http://\$TAILSCALE_IP\"
              echo \"   üìç Tailscale IP:8080: http://\$TAILSCALE_IP:8080\"
            fi
            
            if [[ -n \"\$PUBLIC_IP\" && \"\$PUBLIC_IP\" != \"unavailable\" ]]; then
              echo \"   üåê Public IP: http://\$PUBLIC_IP\"
              echo \"   üåê Public IP:8080: http://\$PUBLIC_IP:8080\"
            fi
            
            # Domain testing if configured
            DOMAIN_NAME=\"ats.7gram.xyz\"  # Fixed domain name for ATS
            if [[ -n \"\$DOMAIN_NAME\" ]]; then
              echo \"   üè∑Ô∏è  Domain: http://\$DOMAIN_NAME\"
              echo \"   üè∑Ô∏è  Domain HTTPS: https://\$DOMAIN_NAME\"
              
              # Test domain resolution
              if nslookup \"\$DOMAIN_NAME\" >/dev/null 2>&1; then
                echo '   ‚úÖ Domain DNS resolution: OK'
              else
                echo '   ‚ùå Domain DNS resolution: FAILED'
              fi
            fi
            echo ''
            
            # Final status summary
            RUNNING_COUNT=\$(docker ps -q | wc -l)
            if [[ \$RUNNING_COUNT -gt 0 ]]; then
              echo \"üéâ === DEPLOYMENT SUCCESSFUL ===\\n‚ÑπÔ∏è  \$RUNNING_COUNT Docker containers are running\"
              
              # Show primary access method
              if [[ -n \"\$TAILSCALE_IP\" && \"\$TAILSCALE_IP\" != \"127.0.0.1\" ]]; then
                echo \"üîó Primary access: http://\$TAILSCALE_IP\"
              elif [[ -n \"\$PUBLIC_IP\" && \"\$PUBLIC_IP\" != \"unavailable\" ]]; then
                echo \"üîó Primary access: http://\$PUBLIC_IP\"
              fi
              
            else
              echo '‚ùå === DEPLOYMENT FAILED ===\\n‚ö†Ô∏è  No containers are running'
              echo ''
              echo 'üîç Troubleshooting information:'
              echo 'üìã All containers (including stopped):'
              docker ps -a
              echo ''
              echo 'üìã Recent Docker logs:'
              docker logs \$(docker ps -aq | head -1) 2>/dev/null | tail -20 || echo 'No logs available'
            fi
            
            # Show recent logs
            echo ''
            echo 'üìù Recent container logs:'
            if [[ -n \"\$COMPOSE_CMD\" ]]; then
              \$COMPOSE_CMD logs --tail=10 2>/dev/null || docker logs \$(docker ps -q | head -1) 2>/dev/null || echo 'Logs unavailable'
            else
              docker logs \$(docker ps -q | head -1) 2>/dev/null || echo 'Logs unavailable'
            fi
          " || {
            echo "‚ö†Ô∏è Failed to start ATS services"
          }

      - name: üß™ Test Game Server
        run: |
          echo "üß™ Testing ATS game server..."
          
          # Wait a bit for services to start and DNS to propagate
          echo "‚è≥ Waiting for services to start and DNS to propagate..."
          sleep 30
          
          TAILSCALE_IP="${{ needs.deploy-ats.outputs.tailscale_ip }}"
          
          # Test web interface via multiple methods
          echo "üåê Testing web interface..."
          
          # Method 1: Test via Tailscale IP (most likely to work)
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 80)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -f http://$TAILSCALE_IP:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via Tailscale IP (port 8080)"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 10 curl -s http://$TAILSCALE_IP | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via Tailscale IP (contains expected content)"
          # Method 2: Test via public domain
          elif timeout 10 curl -f http://ats.7gram.xyz 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 80)"
          elif timeout 10 curl -f http://ats.7gram.xyz:8080 2>/dev/null; then
            echo "‚úÖ ATS web interface responding via public domain (port 8080)"
          elif timeout 10 curl -s http://ats.7gram.xyz | grep -i "ats\|truck\|server" >/dev/null; then
            echo "‚úÖ ATS web page detected via public domain (contains expected content)"
          else
            echo "‚ö†Ô∏è ATS web interface not responding via any method"
            echo "üîç Let's check what's actually running on the server..."
            
            # Get more detailed info about what's running
            if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
              echo "üìä Port scan results:"
              timeout 5 nmap -p 80,8080,27015,19999 $TAILSCALE_IP 2>/dev/null || echo "nmap not available"
              
              # Try to get a raw response
              echo "üìù Raw HTTP response:"
              timeout 5 curl -s http://$TAILSCALE_IP | head -10 || echo "No HTTP response"
            fi
          fi
          
          # Test game server port if accessible
          echo "üéÆ Testing game server port..."
          
          if timeout 5 bash -c "</dev/tcp/ats/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale hostname"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]] && timeout 5 bash -c "</dev/tcp/$TAILSCALE_IP/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via Tailscale IP"
          elif timeout 5 bash -c "</dev/tcp/ats.7gram.xyz/27015" 2>/dev/null; then
            echo "‚úÖ Game server port accessible via public domain"
          else
            echo "‚ÑπÔ∏è Game server port not accessible externally (may be behind firewall or still starting)"
            echo "   This is normal if the game server only accepts connections from Tailscale network"
          fi
          
          echo "üéÆ ATS game server setup complete!"
          echo "üìä Access URLs:"
          echo "  - Tailscale: http://ats:8080 or http://$TAILSCALE_IP:8080"
          echo "  - Public: https://ats.7gram.xyz (after DNS propagation)"
          
          # Final deployment verification
          echo ""
          echo "üéØ Final Deployment Verification:"
          echo "================================"
          
          # Summary of what was accomplished
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" ]]; then
            echo "‚úÖ Server connected to Tailscale: $TAILSCALE_IP"
          else
            echo "‚ö†Ô∏è Tailscale connection status unclear"
          fi
          
          DNS_UPDATED="true"  # Assume DNS was updated in previous step
          if [[ -n "$DNS_UPDATED" && "$DNS_UPDATED" == "true" ]]; then
            echo "‚úÖ DNS record updated for ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è DNS update status unclear"
          fi
          
          # Check repository status
          sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$TAILSCALE_IP "
            if [[ -d '/home/ats_user/ats/.git' ]]; then
              echo '‚úÖ ATS repository cloned successfully'
              cd /home/ats_user/ats && git log --oneline -1 | sed 's/^/    Latest commit: /'
            else
              echo '‚ö†Ô∏è ATS repository not found'
            fi
            
            RUNNING_CONTAINERS=\$(docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -v 'NAMES' | wc -l)
            if [ \"\$RUNNING_CONTAINERS\" -gt 0 ]; then
              echo '‚úÖ Docker services running: '\$RUNNING_CONTAINERS' containers active'
            else
              echo '‚ùå No Docker containers running'
            fi
          " 2>/dev/null || echo "‚ö†Ô∏è Could not verify repository and container status"
          
          echo ""
          echo ""
          echo "ÔøΩ **Testing Summary:**"
          echo "  ‚Ä¢ Basic connectivity tests completed"
          echo "  ‚Ä¢ Game server port availability checked"
          echo "  ‚Ä¢ Web interface accessibility verified"
          echo ""
          echo "üéÆ **Connection Info:**"
          echo "  ‚Ä¢ Game Server: ats.7gram.xyz:27015"
          echo "  ‚Ä¢ Web Interface: https://ats.7gram.xyz"
          echo "  ‚Ä¢ Tailscale Access: http://ats or http://$SERVER_IP"
          echo ""
          echo "ÔøΩ **Additional Notes:**"
          echo "  ‚Ä¢ Services may take a few minutes to fully initialize"
          echo "  ‚Ä¢ Game server should be accessible for multiplayer connections"
          echo "  ‚Ä¢ Check Netdata dashboard for detailed monitoring"

      - name: üê≥ Configure Tailscale Docker Subnets
        env:
          TAILSCALE_AUTHKEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
          SERVER_IP: ${{ needs.deploy-ats.outputs.server_ip }}
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        if: env.TAILSCALE_AUTHKEY != ''
        run: |
          echo "üê≥ Configuring Tailscale to advertise Docker subnets on ATS server..."
          
          # Install sshpass for server connection
          sudo apt-get update && sudo apt-get install -y sshpass >/dev/null 2>&1
          
          # Connect to server and configure Tailscale subnet routing
          TAILSCALE_IP="${{ needs.deploy-ats.outputs.tailscale_ip }}"
          
          # Determine connection method
          if [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]]; then
            SERVER_HOST="$TAILSCALE_IP"
            echo "üîó Using Tailscale IP: $SERVER_HOST"
          elif [[ -n "$SERVER_IP" && "$SERVER_IP" != "null" ]]; then
            SERVER_HOST="$SERVER_IP"
            echo "üîó Using public IP: $SERVER_HOST"
          else
            echo "‚ö†Ô∏è No valid server IP available for configuration"
            exit 0
          fi
          
          echo "üê≥ Configuring Docker subnet advertisement on ATS server..."
          
          # SSH to server and configure Tailscale subnet routing
          sshpass -e ssh -o StrictHostKeyChecking=no ats_user@$SERVER_HOST "
            echo 'üîç Getting Docker network information...'
            
            # Get Docker bridge network CIDR
            DOCKER_SUBNET=\$(docker network inspect bridge --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' 2>/dev/null || echo '172.17.0.0/16')
            echo \"Default Docker subnet: \$DOCKER_SUBNET\"
            
            # Get any custom networks that might exist
            ATS_NETWORKS=\$(docker network ls --format '{{.Name}}' | grep -E 'ats|game' || echo '')
            for network in \$ATS_NETWORKS; do
              if [[ -n \"\$network\" ]]; then
                NETWORK_SUBNET=\$(docker network inspect \$network --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' 2>/dev/null || echo '')
                if [[ -n \"\$NETWORK_SUBNET\" ]]; then
                  echo \"Found ATS network \$network subnet: \$NETWORK_SUBNET\"
                fi
              fi
            done
            
            # Configure Tailscale to advertise Docker subnets
            echo 'üåê Configuring Tailscale subnet advertisement...'
            
            # For now, just advertise the main Docker bridge network
            SUBNETS=\"\$DOCKER_SUBNET\"
            echo \"Advertising subnets: \$SUBNETS\"
            
            # Configure Tailscale with subnet routing
            sudo tailscale up --advertise-routes=\"\$SUBNETS\" --accept-routes || {
              echo '‚ö†Ô∏è Failed to configure subnet routing, trying basic reconnection...'
              sudo tailscale up --accept-routes
            }
            
            # Verify configuration
            echo '‚úÖ Tailscale subnet configuration completed'
            tailscale status || echo 'Tailscale status check failed'
            
          " || echo "‚ö†Ô∏è Failed to configure Tailscale subnets"

      - name: üìä Verify Netdata Cloud Connection
        env:
          SSHPASS: ${{ secrets.ACTIONS_USER_PASSWORD }}
        run: |
          echo "üìä Verifying Netdata cloud connection..."
          
          TAILSCALE_IP="${{ needs.deploy-ats.outputs.tailscale_ip }}"
          
          # Determine server connection method (same as before)
          if timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats"
          elif [[ -n "$TAILSCALE_IP" && "$TAILSCALE_IP" != "unknown" && "$TAILSCALE_IP" != "pending" ]] && timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@$TAILSCALE_IP "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="$TAILSCALE_IP"
          elif timeout 10 sshpass -e ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ats_user@ats.7gram.xyz "echo 'Connected'" 2>/dev/null; then
            SERVER_HOST="ats.7gram.xyz"
          else
            echo "‚ö†Ô∏è Cannot connect to check Netdata status"
            exit 0
          fi
          
          echo "üîç Checking Netdata status on $SERVER_HOST..."
          
          # Check if Netdata is running and accessible
          sshpass -e ssh -o StrictHostKeyChecking=no ats_user@$SERVER_HOST "
            echo 'üìä Netdata service status:'
            sudo systemctl is-active netdata && echo '‚úÖ Netdata service is active' || echo '‚ö†Ô∏è Netdata service is not active'
            
            echo ''
            echo 'üåê Testing Netdata web interface:'
            if curl -f http://localhost:19999/api/v1/info 2>/dev/null >/dev/null; then
              echo '‚úÖ Netdata web interface is accessible'
            else
              echo '‚ö†Ô∏è Netdata web interface is not accessible'
            fi
            
            echo ''
            echo '‚òÅÔ∏è Checking Netdata cloud connection:'
            if [[ -f /var/lib/netdata/cloud.d/token ]]; then
              echo '‚úÖ Netdata cloud token file exists'
            else
              echo '‚ö†Ô∏è Netdata cloud token file not found'
            fi
            
            # Check if claiming is successful
            if [[ -f /var/lib/netdata/registry/netdata.public.unique.id ]]; then
              echo '‚úÖ Netdata unique ID exists'
              NETDATA_ID=\$(cat /var/lib/netdata/registry/netdata.public.unique.id 2>/dev/null || echo 'unknown')
              echo 'Netdata ID: '\$NETDATA_ID
            else
              echo '‚ö†Ô∏è Netdata unique ID not found'
            fi
            
            # Try to reclaim if needed
            if [[ ! -f /var/lib/netdata/cloud.d/token ]]; then
              echo ''
              echo 'üîÑ Attempting to reclaim Netdata to cloud...'
              
              # Find the claim script
              CLAIM_SCRIPT=''
              for script_path in \"/usr/sbin/netdata-claim.sh\" \"/opt/netdata/bin/netdata-claim.sh\" \"/usr/libexec/netdata/netdata-claim.sh\" \"/usr/lib/netdata/netdata-claim.sh\"; do
                if [[ -f \"\$script_path\" ]]; then
                  CLAIM_SCRIPT=\$script_path
                  break
                fi
              done
              
              if [[ -z \"\$CLAIM_SCRIPT\" ]]; then
                CLAIM_SCRIPT=\$(find /usr /opt -name \"netdata-claim.sh\" 2>/dev/null | head -1)
              fi
              
              if [[ -n \"\$CLAIM_SCRIPT\" && -f \"\$CLAIM_SCRIPT\" ]]; then
                echo \"Found claim script: \$CLAIM_SCRIPT\"
                sudo \"\$CLAIM_SCRIPT\" -token=\"${{ secrets.NETDATA_CLAIM_TOKEN }}\" \\
                  -rooms=\"${{ secrets.NETDATA_CLAIM_ROOM }}\" \\
                  -url=\"https://app.netdata.cloud\" && \\
                  echo '‚úÖ Netdata reclaim completed' || echo '‚ö†Ô∏è Netdata reclaim failed'
                
                # Restart Netdata after claiming
                sudo systemctl restart netdata
                sleep 5
              else
                echo '‚ö†Ô∏è Netdata claim script not found'
              fi
            fi
          " || echo "‚ö†Ô∏è Failed to check Netdata status"
          
          echo ""
          echo "üìä Netdata URLs:"
          echo "  - Local: http://ats:19999 or http://$TAILSCALE_IP:19999"
          echo "  - Cloud: https://app.netdata.cloud (if claimed successfully)"
